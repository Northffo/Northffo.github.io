<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(转载)Docker常用命令</title>
    <url>/2025/02/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><a href="https://www.yuque.com/leifengyang/sutong/au0lv3sv3eldsmn8">docker常用命令</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JYY&#39;s ICS2020 PA1</title>
    <url>/2024/02/22/JYY-s-ICS2020-PA1/</url>
    <content><![CDATA[<h2 id="开天辟地的篇章"><a href="#开天辟地的篇章" class="headerlink" title="开天辟地的篇章"></a>开天辟地的篇章</h2><blockquote>
<p>从状态机视角理解程序运行</p>
</blockquote>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">// PC: instruction    | // label: statement</span><br><span class="line"><span class="number">0</span>: <span class="keyword">mov</span>  <span class="built_in">r1</span>, <span class="number">0</span>         |  pc0: <span class="built_in">r1</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="number">1</span>: <span class="keyword">mov</span>  <span class="built_in">r2</span>, <span class="number">0</span>         |  pc1: <span class="built_in">r2</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="number">2</span>: addi <span class="built_in">r2</span>, <span class="built_in">r2</span>, <span class="number">1</span>     |  pc2: <span class="built_in">r2</span> = <span class="built_in">r2</span> + <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="number">3</span>: <span class="keyword">add</span>  <span class="built_in">r1</span>, <span class="built_in">r1</span>, <span class="built_in">r2</span>    |  pc3: <span class="built_in">r1</span> = <span class="built_in">r1</span> + <span class="built_in">r2</span><span class="comment">;</span></span><br><span class="line"><span class="number">4</span>: blt  <span class="built_in">r2</span>, <span class="number">100</span>, <span class="number">2</span>    |  pc4: if (<span class="built_in">r2</span> &lt; <span class="number">100</span>) goto pc2<span class="comment">;   // branch if less than</span></span><br><span class="line"><span class="number">5</span>: <span class="keyword">jmp</span> <span class="number">5</span>              |  pc5: goto pc5<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>Q：画出这个程序的状态机</p>
<p>需要更新的状态只包括PC，r1和r0，所以用三元组表示程序的所有状态:</p>
<p>(0, x, x) -&gt; (1, 0, x) -&gt; (2, 0, 0) -&gt; (3, 0, 1) -&gt; (4, 1, 1) -&gt; (2, 1, 1) -&gt; (3, 1, 2) -&gt; (4, 3, 2) -&gt; … -&gt; (2, 4851, 98) -&gt; (3, 4851, 99) -&gt; (4, 4950, 99) -&gt; (2, 4950, 99) -&gt; (3, 4950, 100) -&gt; (4, 5050, 100) -&gt; (5, 5050, 100)</p>
<ul>
<li><strong>Thoughts</strong> : 如果不是实验中给出了初始的<code>(0, x, x) -&gt; (1, 0, x) -&gt; (2, 0, 0) -&gt; .. </code>, 以我的感觉我极有可能会写(0, 1, x) -&gt; (1, 0, 0) -&gt; .. 我的逻辑是在<code>pc0</code>的时候，<code>r1</code>赋值为0了， 但是在状态机中表示的是一个瞬间的状态所以在<code>pc0</code>的时候, <code>r1</code>还没有被赋值，所以上面的(0, x, x)是对的</li>
</ul>
<span id="more"></span>

<blockquote>
<p>RTFSC</p>
</blockquote>
<p><strong>函数</strong>: <a href="./getopt-%E5%87%BD%E6%95%B0.md">getopt()</a></p>
<p><strong>变量</strong>: <code>_IMAGE_START_</code>: 客户程序的固定内存位置</p>
<p><strong>x86寄存器结构实现</strong>: </p>
<p>原题： </p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">* <span class="doctag">TODO:</span> Re-organize the `CPU_state&#x27; structure to match the register                                 │</span></span><br><span class="line"><span class="comment">* encoding scheme in i386 instruction format. For example, if we                                    │</span></span><br><span class="line"><span class="comment">* access cpu.gpr[3]._16, we will get the `bx&#x27; register; if we access                                │</span></span><br><span class="line"><span class="comment">* cpu.gpr[1]._8[1], we will get the &#x27;ch&#x27; register. Hint: Use `union&#x27;.                               │</span></span><br><span class="line"><span class="comment">* For more details about the register encoding scheme, see i386 manual.                             │</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<p>题目很明显需要我们将RTL寄存器与通用寄存器(GPRs)联系起来(很尴尬的是刚开始我并没有看到这段话T_T)， 并提示我们使用union来实现。</p>
<p>源代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> _32;</span><br><span class="line">    <span class="type">uint16_t</span> _16;</span><br><span class="line">    <span class="type">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">  &#125; gpr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do NOT change the order of the GPRs&#x27; definitions. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions</span></span><br><span class="line"><span class="comment">    in PA2 able to directly access these registers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line"></span><br><span class="line">  <span class="type">vaddr_t</span> pc;</span><br><span class="line">&#125; x86_CPU_state;</span><br></pre></td></tr></table></figure>

<p>那么有了提示思路就很明确， 我们只需要把gpr[]数组跟各个rtlreg共享内存位置即可。</p>
<p>于是我首先是这样构造：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        uint32_t _32<span class="comment">;</span></span><br><span class="line">        uint16_t _16<span class="comment">;</span></span><br><span class="line">        uint8_t _8[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    &#125; gpr[<span class="number">8</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    struct &#123;</span><br><span class="line">        rtlreg_t eax<span class="comment">;</span></span><br><span class="line">        rtlreg_t edx<span class="comment">;</span></span><br><span class="line">        rtlreg_t ecx<span class="comment">;</span></span><br><span class="line">        rtlreg_t ebx<span class="comment">;</span></span><br><span class="line">        rtlreg_t ebp<span class="comment">;</span></span><br><span class="line">        rtlreg_t esi<span class="comment">;</span></span><br><span class="line">        rtlreg_t edi<span class="comment">;</span></span><br><span class="line">        rtlreg_t esp<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;    </span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>很明显的，gpr[]数组的跟RTLREG结构体共享同一段地址，我们对gpr[]每个元素的修改也会直接影响到RTLREG的值。</p>
<p>但是，<font color='red'>测试不通过</font></p>
<p>我很奇怪，但是找不到任何问题，在我不知道怎么修改的乱修改之后发现只要把gpr[]数组也改成union联合体就可以：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t _32<span class="comment">;</span></span><br><span class="line">        uint16_t _16<span class="comment">;</span></span><br><span class="line">        uint8_t _8[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    &#125; gpr[<span class="number">8</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    struct &#123;</span><br><span class="line">        rtlreg_t eax<span class="comment">;</span></span><br><span class="line">        rtlreg_t edx<span class="comment">;</span></span><br><span class="line">        rtlreg_t ecx<span class="comment">;</span></span><br><span class="line">        rtlreg_t ebx<span class="comment">;</span></span><br><span class="line">        rtlreg_t ebp<span class="comment">;</span></span><br><span class="line">        rtlreg_t esi<span class="comment">;</span></span><br><span class="line">        rtlreg_t edi<span class="comment">;</span></span><br><span class="line">        rtlreg_t esp<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;    </span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>从整体看，我并没有找到问题， 两段代码都是对rtlreg和gpr[]数组的内存地址统一，从功能上来看都是相同的。</p>
<p>答案就是, 在第一段代码中gpr[]是一个<strong>结构体</strong>代码，那么就意味着在结构体中的变量是一段连续内存地址中相互独立的：<strong>每个成员占有独立的内存空间</strong>, _32, _16, _8[2]都是独立的内存地址， 而这显然不符合寄存器的结构， 在<a href="https://css.csail.mit.edu/6.858/2013/readings/i386.pdf">i386手册</a>中，通用寄存器是这么定义的:</p>
<p><img src="/2024/02/22/JYY-s-ICS2020-PA1/PA1-i386%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" alt="PA1-i386通用寄存器内存地址"></p>
<p>那么在第二段代码中_32, _16, _8[2]本质是共享了同一段内存地址，这意味着对其中任一成员的修改都会影响到同一内存位置的其他成员。</p>
<p><strong>一些奇怪的问题</strong>：</p>
<p>在上面图片中可以看到，RTLREG的顺序跟我的结构体中的顺序并不相同，但是却可以<font color=green>正常运行</font>, 但是当我按照图片上的顺序修改之后却<font color=red>无法运行</font>。</p>
]]></content>
      <categories>
        <category>ICS2020</category>
      </categories>
      <tags>
        <tag>ICS2020</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/2024/02/21/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux-命令总结"><a href="#Linux-命令总结" class="headerlink" title="Linux 命令总结"></a>Linux 命令总结</h1><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul>
<li><code>cd &lt;directory&gt;</code>: 更改当前工作目录到指定的目录。</li>
<li><code>pwd</code>: 显示当前工作目录的完整路径。</li>
<li><code>mkdir &lt;directory&gt;</code>: 创建一个新目录。</li>
<li><code>rmdir &lt;directory&gt;</code>: 删除一个空目录。如果目录非空，使用<code>rm -r &lt;directory&gt;</code>。</li>
<li><code>ls [options] [file]</code>: 列出目录内容。<ul>
<li><code>-l</code>: 长格式列出信息。</li>
<li><code>-a</code>: 列出所有文件，包括隐藏文件。</li>
<li><code>-h</code>: 与<code>-l</code>一起使用时，以易读的方式显示文件大小。</li>
</ul>
</li>
<li><code>cp [options] &lt;source&gt; &lt;destination&gt;</code>: 复制文件或目录。<ul>
<li><code>-r</code> 或 <code>--recursive</code>: 递归复制目录及其内容。</li>
<li><code>-i</code> 或 <code>--interactive</code>: 在覆盖文件之前提示用户确认。</li>
<li><code>-v</code> 或 <code>--verbose</code>: 显示详细信息。</li>
</ul>
</li>
<li><code>rm [options] &lt;file&gt;</code>: 删除文件或目录。<ul>
<li><code>-r</code> 或 <code>--recursive</code>: 递归地删除目录及其内容。</li>
<li><code>-f</code> 或 <code>--force</code>: 强制删除，不提示确认。</li>
</ul>
</li>
<li><code>mv [options] &lt;source&gt; &lt;destination&gt;</code>: 移动或重命名文件或目录。</li>
<li><code>tar [options] &lt;filename&gt; [files]</code>: 用于归档文件，同时可对文件进行压缩或解压。<ul>
<li><code>-c</code>: 创建归档。</li>
<li><code>-x</code>: 从归档中提取文件。</li>
<li><code>-z</code>: 通过gzip进行压缩或解压。</li>
<li><code>-v</code>: 显示被处理的文件名。</li>
<li><code>-f</code>: 指定归档文件的名称。<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h2><ul>
<li><code>cat &lt;file&gt;</code>: 显示文件内容。</li>
<li><code>more &lt;file&gt;</code>: 分页显示文件内容。</li>
<li><code>less &lt;file&gt;</code>: 类似于<code>more</code>，但允许反向导航。</li>
<li><code>head [options] &lt;file&gt;</code>: 显示文件的开头部分。</li>
<li><code>tail [options] &lt;file&gt;</code>: 显示文件的结尾部分。</li>
<li><code>file &lt;file&gt;</code>: 确定文件类型。</li>
<li><code>find [path] [expression]</code>: 搜索文件和目录。<ul>
<li><code>-name</code>: 根据文件名搜索。</li>
<li><code>-type</code>: 指定文件类型进行搜索。</li>
<li><code>-exec</code>: 对搜索结果执行指定的命令。</li>
</ul>
</li>
</ul>
<h2 id="输入输出控制"><a href="#输入输出控制" class="headerlink" title="输入输出控制"></a>输入输出控制</h2><ul>
<li>重定向 (<code>&gt;</code> 和 <code>&lt;</code>): 将命令的输出重定向到文件或从文件中读取输入。</li>
<li>管道 (<code>|</code>): 将一个命令的输出作为另一个命令的输入。</li>
<li><code>tee &lt;file&gt;</code>: 读取标准输入的数据，并同时写入文件和标准输出。</li>
<li><code>xargs</code>: 构造参数列表并执行命令。</li>
</ul>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><ul>
<li><code>vim &lt;file&gt;</code>: 打开Vim文本编辑器以编辑文件。</li>
<li><code>grep [options] &lt;pattern&gt; [file]</code>: 搜索文本并打印匹配行。<ul>
<li><code>-i</code>: 忽略大小写差异。</li>
<li><code>-r</code> 或 <code>--recursive</code>: 递归搜索子目录中的文件。</li>
<li><code>-v</code>: 反转匹配。</li>
</ul>
</li>
<li><code>awk [program] [file]</code>: 强大的文本处理工具，用于模式扫描和处理。</li>
<li><code>sed [options] [script] [file]</code>: 流编辑器，用于处理文本流。</li>
<li><code>sort [options] [file]</code>: 对文件中的行进行排序。</li>
<li><code>wc [options] [file]</code>: 统计文件的行数、字数和字节数。</li>
<li><code>uniq [options] [input] [output]</code>: 报告或省略重复行。</li>
<li><code>cut [options] [file]</code>: 从文件的每一行剪切字节、字符和字段。</li>
<li><code>tr [options] &lt;set1&gt; &lt;set2&gt;</code>: 替换或删除字符。</li>
</ul>
<h2 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h2><ul>
<li><code>jobs</code>: 列出当前会话中的所有任务。</li>
<li><code>ps [options]</code>: 显示当前进程的快照。</li>
<li><code>top</code>: 显示实时运行系统的进程信息。</li>
<li><code>kill [options] &lt;pid&gt;</code>: 发送信号到一个或多个进程。</li>
<li><code>free</code>: 显示内存的使用情况。</li>
<li><code>dmesg</code>: 显示或控制内核环形缓冲区的内容。</li>
<li><code>lsof [options]</code>: 列出被进程打开的文件。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何确定文件类型以及文件拓展名</title>
    <url>/2024/02/19/Linux%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E6%8B%93%E5%B1%95%E5%90%8D/</url>
    <content><![CDATA[<p>前几天在做蒋炎岩老师的PA有一个小<a href="https://www.cprogramming.com/gdb.html">实验</a>在实验中使用<code>g++ main.cpp -o main</code>来编译cpp文件, 但是上面的-o其实是g++的一个选项, 作用是自定义生成文件的名称, 上面的指令就是编译<code>main.cpp</code>文件, 并将编译后的可执行文件命名为main.</p>
<p>所以编译c文件其实只需要<code>gcc main.c</code>指令, 这条指令会默认生成a.out可执行文件</p>
<p>我突然想到一个问题, 是不是上面的main也是.out文件, 但是在我查阅资料后发现并不是这样:</p>
<span id="more"></span>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">g++ <span class="selector-tag">main</span><span class="selector-class">.cpp</span> -o hello</span><br></pre></td></tr></table></figure>

<p>使用-o选项是可以自定义可执行文件的名称,这里生成的是hello,注意文件的拓展名并不是.out</p>
<p>文件的拓展名对linux来说并不重要, 可执行文件的性质由其权限和格式决定.</p>
<blockquote>
<h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>在Linux和其他类Unix系统中，文件权限控制着文件的可访问性。这些权限指定了哪些用户可以读取、写入或执行某个文件。如果一个文件被标记为可执行（通常通过设置执行权限位，例如使用chmod +x filename命令），那么系统的用户（根据文件的权限设置）就可以尝试执行这个文件。</p>
</blockquote>
<blockquote>
<h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><p>可执行文件需要有特定的格式，最常见的是ELF（Executable and Linkable Format）格式。这个格式告诉操作系统如何加载程序到内存中并执行它。只有符合系统预期的可执行格式的文件才能被作为程序运行。即使一个文件具有执行权限，如果它不是有效的可执行格式，操作系统也无法执行它。</p>
</blockquote>
<blockquote>
<h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件是否可以执行与其名字无关。你可以把一个可执行文件重命名为任何名字，只要它保持了执行权限和有效的可执行格式，它就仍然是可执行的。例如，你可以将一个编译好的程序从program重命名为program.out或任何其他名字，这不会影响其作为可执行文件的能力.</p>
</blockquote>
<h4 id="文件扩展名的作用"><a href="#文件扩展名的作用" class="headerlink" title="文件扩展名的作用"></a>文件扩展名的作用</h4><p>用户提示：文件扩展名帮助用户和应用程序理解文件的预期用途和内容类型。例如，.txt通常表示纯文本文件，.png表示PNG图像文件。<br>应用程序关联：许多图形用户界面（GUI）环境和应用程序使用文件扩展名来判断如何打开特定的文件。例如，双击一个.pdf文件通常会打开一个PDF阅读器应用程序。<br>命令行工具：一些命令行工具可能也会根据文件扩展名来处理文件，尽管这不是强制的。例如，编译器如gcc不会根据源代码文件的扩展名来改变其行为，但它默认接受.c作为C语言源代码文件的扩展名。</p>
<h4 id="Linux如何确定文件类型"><a href="#Linux如何确定文件类型" class="headerlink" title="Linux如何确定文件类型"></a>Linux如何确定文件类型</h4><p>Linux使用几种方法来确定如何处理文件，不仅仅依靠文件扩展名：<br>文件权限：如之前讨论的，文件的权限（特别是执行权限）决定了用户是否可以执行该文件。<br>文件内容：<strong>Linux可以通过文件的前几个字节（称为“魔数(magic number)”）来识别文件的类型</strong>。例如，可执行文件、图像文件等都有特定的开头字节序列。<br>解释器指令行：对于脚本文件（如.sh、.py等），第一行通常包含一个称为shebang（#!）的指令，指明了执行该脚本时应使用的解释器路径。这允许直接执行脚本文件，而不依赖于文件的扩展名。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Cpp/C</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX网络编程_1</title>
    <url>/2025/04/06/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/</url>
    <content><![CDATA[<h1 id="一个简单的时间获取客户程序"><a href="#一个简单的时间获取客户程序" class="headerlink" title="一个简单的时间获取客户程序"></a>一个简单的时间获取客户程序</h1><blockquote>
<p>本系统： Debian 12</p>
</blockquote>
<blockquote>
<p>如何下载源码并编译运行</p>
</blockquote>
<p>官方源码地址：<a href="https://github.com/unpbook/unpv13e">https://github.com/unpbook/unpv13e</a></p>
<p><code>git clone https://github.com/unpbook/unpv13e.git </code></p>
<p>克隆到本地之后，根据README文件一步一步make配置</p>
<p>接下来可以直接<code> make 想要运行的源码</code> 然后执行即可</p>
<span id="more"></span>

<ul>
<li><h3 id="一个问题：如何使用gcc来编译官方的源码"><a href="#一个问题：如何使用gcc来编译官方的源码" class="headerlink" title="一个问题：如何使用gcc来编译官方的源码"></a>一个问题：如何使用gcc来编译官方的源码</h3><p><strong>首先把生成的静态库libudp.a 复制到系统依赖文件夹中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..   //回到unpv13e目录  </span><br><span class="line">sudo cp libunp.a /usr/lib  </span><br><span class="line">sudo cp libunp.a /usr/lib64 </span><br></pre></td></tr></table></figure>

<p><strong>然后修改unp.h并将其和config.h拷贝到&#x2F;usr&#x2F;include中，为了以后include方便</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit lib/unp.h   //将unp.h中#include &quot;../config.h&quot;修改为#include &quot;config.h&quot;  </span><br><span class="line">sudo cp lib/unp.h /usr/include  </span><br><span class="line">sudo cp config.h /usr/include  </span><br></pre></td></tr></table></figure>

<p>然后就可以愉快的编译了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./intro  </span><br><span class="line">gcc daytimetcpcli.c -o daytimetcpcli -lunp  		// 链接unp库</span><br></pre></td></tr></table></figure>


</li>
<li><h3 id="同理，如果想要自己重新另建一个文件夹来编译运行的话"><a href="#同理，如果想要自己重新另建一个文件夹来编译运行的话" class="headerlink" title="同理，如果想要自己重新另建一个文件夹来编译运行的话"></a>同理，如果想要自己重新另建一个文件夹来编译运行的话</h3><p>首先要完成上面的步骤：静态库和头文件的拷贝</p>
<p>然后就可以使用<code>gcc daytimetcpcli.c -o daytimetcpcli -lunp  </code>来运行了</p>
</li>
<li><h3 id="另一个问题：如何使用两台主机测试"><a href="#另一个问题：如何使用两台主机测试" class="headerlink" title="另一个问题：如何使用两台主机测试"></a>另一个问题：如何使用两台主机测试</h3><p>这里我使用的是阿里云服务器</p>
<p>**关键就是你要在安全组里开放13端口（时间服务器端口），而不是进程的端口号 **</p>
<p>这里测试的话你可以使用下面命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping ipadress			# 使用ping命令测试本地主机能否连接服务器</span><br><span class="line">telnet ipaddress 13		# 使用telnet命令测试服务器端口是否正常开启</span><br></pre></td></tr></table></figure>



<p>你可以在云服务器中使用下面命令来开放监听端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./daytimetcpsrv &amp;</span><br></pre></td></tr></table></figure>

<p>然后在本地主机上使用下面命令来测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./daytimetcpcli ipaddress	# 这里替换为云服务器的ip地址</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>参考</p>
<p><a href="https://www.cnblogs.com/afestival/articles/2586850.html">unix网络编程：编译源代码相关的问题</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux 网络编程 云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>concat宏浅析</title>
    <url>/2024/03/11/concat%E5%AE%8F%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>concat 是一个常见的宏编程技术，用于将两个或多个预处理器标记（通常是宏参数或宏定义）连接（concatenate）成一个单一的标记, 通常通过使用预处理器的 ## 操作符实现，该操作符用于连接两个标记。</p>
<h4 id="Concat-宏的基本用法"><a href="#Concat-宏的基本用法" class="headerlink" title="`Concat`宏的基本用法"></a>`Concat`宏的基本用法</h4><p>假设有一个 <code>concat</code> 宏定义如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#define</span> concat(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>) <span class="selector-tag">a</span> ## <span class="selector-tag">b</span></span><br></pre></td></tr></table></figure>
<p>这里，## 操作符会将它的两个参数 a 和 b 连接成一个单一的标记。</p>
<span id="more"></span>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>使用 concat 来动态创建函数名：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个示例函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func123</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 concat 宏来连接 &#x27;func&#x27; 和 &#x27;123&#x27;，生成函数名 &#x27;func123&#x27;</span></span><br><span class="line">    concat(func, <span class="number">123</span>)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，concat(func, 123) 会在预处理阶段被展开为 func123，因此 concat(func, 123)(); 实际上调用的是 func123()函数。    </p>
]]></content>
      <categories>
        <category>C/CPP</category>
      </categories>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc常用选项</title>
    <url>/2024/03/14/gcc%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="一些gcc常用的选项"><a href="#一些gcc常用的选项" class="headerlink" title="一些gcc常用的选项"></a>一些gcc常用的选项</h3><ul>
<li><code>-c</code>: 只编译但不链接， 生成目标文件(.o)， 无法识别的文件将被忽略; 原文：</li>
</ul>
<p>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</p>
<p>By default, the object file name for a source file is made by replacing the suffix ‘.c’, ‘.i’, ‘.s’, etc., with ‘.o’.</p>
<p>Unrecognized input files, not requiring compilation or assembly, are ignored.</p>
<ul>
<li><p><code>-S</code> ： 将源代码编译成汇编代码，而不是直接生成机器代码或可执行文件。使用这个选项时，GCC会执行编译过程中的前几个步骤（如预处理、编译），但会停在生成汇编代码这一步，不会进一步进行汇编成目标代码或进行链接。</p>
</li>
<li><p><code>-E</code>: -E选项用于仅执行预处理步骤。GCC会处理源代码中的预处理指令，如宏定义的扩展、条件编译指令的处理、包含文件的插入等，但它不会编译、汇编或链接代码。注意： 默认情况下，这个输出会直接发送到标准输出（即屏幕）， 所以可以使用<code>|</code>传到vim或者其他编辑器中查看:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">gcc -E helloworld.c <span class="string">| vim -  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-o</code>: 这一部分强烈推荐看<a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Overall-Options.html">原文</a>, <code>-o</code>选项允许指定主输出文件的名称和位置，这适用于任何类型的输出，无论是可执行文件、目标文件、汇编文件还是预处理的C代码。</p>
<span id="more"></span>

<ul>
<li><p>这一部分我直接贴出gpt对原文的解读：</p>
<p><strong>主输出定位</strong>：如果没有指定-o选项，默认情况下，可执行文件会被放置在a.out中，源文件source.suffix的目标文件会命名为source.o，其汇编文件命名为source.s，预编译头文件命名为source.suffix.gch，所有预处理的C源代码输出到标准输出（屏幕）。</p>
<p><strong>辅助输出和转储输出</strong>：虽然-o仅指定主输出，但它也影响辅助输出和转储输出的命名和定位。除非有其他指定，这些输出文件默认被放置在主输出文件相同的目录下。对于辅助输出，输入文件的后缀会被替换为辅助输出文件类型的后缀；对于转储输出，转储文件的后缀会被添加到输入文件后缀之后。在编译命令中，辅助输出和转储输出的基础名称是主输出的名称；在编译并链接命令中，主输出名称（去掉可执行文件后缀）与输入文件名称结合使用。如果它们的基础名称相同，结果就是该基础名称，否则，它们通过短横线连接。</p>
<p> <strong>示例</strong>：</p>
<p> <code>gcc -c foo.c ...</code>会产生<code>foo.o</code>作为主输出，辅助输出和转储输出也会放置在它旁边，例如辅助文件<code>foo.dwo</code>（对于<code>-gsplit-dwarf</code>）和转储文件<code>foo.c.???r.final</code>（对于<code>-fdump-rtl-final</code>）。</p>
<p>如果明确指定了非链接器的输出文件，辅助和转储文件默认使用相同的基础名称。例如，<code>gcc -c foo.c -o dir/foobar.o ...</code>将辅助输出命名为<code>dir/foobar.*</code>，转储输出命名为<code>dir/foobar.c.*</code>。</p>
<p>链接输出会为辅助和转储输出添加前缀。例如，<code>gcc foo.c bar.c -o dir/foobar ...</code>通常会将辅助输出命名为<code>dir/foobar-foo.*和dir/foobar-bar.*</code>，转储输出命名为<code>dir/foobar-foo.c.*</code>和<code>dir/foobar-bar.c.*</code>。</p>
<p>唯一的例外是当可执行文件与单一输入文件共享基础名称时，例如<code>gcc foo.c -o dir/foo ...</code>，这种情况下，辅助输出被命名为<code>dir/foo.*</code>，转储输出被命名为<code>dir/foo.c.*</code>。</p>
<p><strong>调整辅助和转储输出的位置和名称</strong>：可以通过<code>-dumpbase</code>、<code>-dumpbase-ext</code>、<code>-dumpdir</code>、<code>-save-temps=cwd</code>和<code>-save-temps=obj</code>选项调整辅助和转储输出的位置和名称。</p>
<p>简而言之，-o选项不仅允许你指定主输出文件的名称和位置，它还间接影响了辅助输出和转储输出的命名和定位规则。这在管理大型项目和自定义构建过程时非常有用。</p>
</li>
</ul>
</li>
<li><p><code>-g</code>: 在可执行文件中生成标准调试信息。<code>-g</code>选项生成的调试信息会尽量适配不同的调试器，但主要还是以GDB（GNU Debugger）为主。</p>
</li>
<li><p><code>-ggdb</code> :为GDB调试器优化，生成最丰富的调试信息,包括一些特定于GDB的优化，以提供更好的调试体验。</p>
</li>
<li><p><code>-Wall</code>: 开启大多数编译器警告，有助于发现潜在的错误。</p>
</li>
<li><p><code>Werror</code>: 将所有的警告当作错误处理。</p>
</li>
<li><p><code>-D</code>: 定义宏，即在编译时从命令行向源代码中引入宏定义。 基本语法如下： <code>-Dname</code>或者<code>-Dname=definition</code>, 其中，name是要定义的宏的名称，definition是这个宏的值。如果没有指定definition，宏name的值默认为1。</p>
<ul>
<li>eg:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is enabled.\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is not enabled.\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  使用-D选项来定义DEBUG宏：<br>  <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">gcc -DDEBUG <span class="built_in">example</span>.c -o <span class="built_in">example</span></span><br></pre></td></tr></table></figure><br>  这将使得编译的程序在运行时输出：“Debug mode is enabled.” 因为DEBUG宏在编译时被定义了，所以预处理器会包含#ifdef DEBUG和#endif之间的代码。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C/CPP 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>getopt()函数</title>
    <url>/2024/02/26/getopt-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在读nemu&#x2F;src&#x2F;monitor&#x2F;monitor.c中遇到了这个函数,原文如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">parse_args</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">option</span> table[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;batch&quot;</span>    , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;log&quot;</span>      , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;diff&quot;</span>     , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;port&quot;</span>     , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>     , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>          , <span class="number">0</span>                , <span class="literal">NULL</span>,  <span class="number">0</span> &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">int</span> o;</span><br><span class="line">  <span class="keyword">while</span> ( (o = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;-bhl:d:p:&quot;</span>, table, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: batch_mode = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%d&quot;</span>, &amp;difftest_port); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: log_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: diff_so_file = optarg; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (img_file != <span class="literal">NULL</span>) <span class="built_in">Log</span>(<span class="string">&quot;too much argument &#x27;%s&#x27;, ignored&quot;</span>, optarg);</span><br><span class="line">        <span class="keyword">else</span> img_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [OPTION...] IMAGE\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-b,--batch              run with batch mode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-l,--log=FILE           output log to FILE\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-d,--diff=REF_SO        run DiffTest with reference REF_SO\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t-p,--port=PORT          run DiffTest with port PORT\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>这个函数中使用了getopt_long()函数, 在<code>man 3 getopt</code>并查阅资料后，对这个函数有了初步的了解<br>#</p>
<blockquote>
<p>概要：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="type">char</span> *optstring)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line">       <span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt;</span><br><span class="line"></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">getopt_long</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="type">char</span> *optstring,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> option *longopts, <span class="type">int</span> *longindex)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">getopt_long_only</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="type">char</span> *optstring,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> option *longopts, <span class="type">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>char *optarg</code>：指向当前选项参数（如果有）的指针。</p>
<p><code>int optind</code>：下一次调用 getopt() 时的 argv 索引的起始位置。</p>
<p><code>int opterr</code>：如果非零，getopt() 会在遇到错误时打印错误消息。如果把opterr设置为0， 那么getopt()就不会自动错误报告</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><code>getopt()</code>其实是一个提供解析命令行参数的函数，<code>getopt()</code>函数使得程序能够以一种标准的方式来解析命令行选项（如 <code>-a</code> 或 <code>--option</code> 这样的短选项或长选项）。</p>
<blockquote>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4></blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span></span>; </span><br></pre></td></tr></table></figure>

<p><code>argc </code>和 <code>argv[]</code>：这两个参数直接来自于程序的 main() 函数，代表命令行参数的数量和参数的字符串数组。<br><code>optstring</code>：一个包含有效选项字符的字符串。如果一个选项字符后面跟随一个冒号（:），那么表示该选项需要一个参数（例如，-f filename 中的 filename 就是 -f 选项的参数）。 eg: <code>optstring</code> &#x3D; <strong>“abc:d”</strong> ,那么说明一共有四个选项-a、-b、-c、-d, 其中c后面跟一个冒号，说明在使用-c选项的时候需要提供一个参数。</p>
<blockquote>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4></blockquote>
<p><code>getopt() </code>函数在每次调用时都会返回命令行中的下一个选项字符，直到所有选项都被处理完毕，此时返回 -1。处理选项时，如果遇到未定义的选项字符，getopt() 会打印一个错误消息到标准错误并返回 ?。如果选项需要一个参数但未提供参数，根据 optstring 的第一个字符是否为 :，getopt() 返回 ? 或 : 来区分错误类型。</p>
<blockquote>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4></blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;if:lr&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Option: %c\n&quot;</span>, opt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Filename: %s\n&quot;</span>, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s [-ilr] [-f filename] args\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = optind; index &lt; argc; index++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non-option argument: %s\n&quot;</span>, argv[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提供了四个选项-i、-f、-l、-r, 其中使用-f选项的时候需要提供一个参数， 如果提供的选项没有定义，就会打印Non-option argument</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>vim test_getopt.c </span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>gcc test_getopt.c </span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -i</span><br><span class="line"><span class="symbol">Option:</span> i</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -f <span class="string">&quot;1121&quot;</span></span><br><span class="line"><span class="symbol">Filename:</span> <span class="number">1121</span></span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -a</span><br><span class="line">./<span class="symbol">a.out:</span> invalid option -- <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="symbol">Usage:</span> ./a.out [-ilr] [-f filename] args</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -f</span><br><span class="line">./<span class="symbol">a.out:</span> option requires an argument -- <span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="symbol">Usage:</span> ./a.out [-ilr] [-f filename] args</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out f</span><br><span class="line"><span class="title class_">Non</span>-option <span class="symbol">argument:</span> f</span><br></pre></td></tr></table></figure>

<p>由上可以看出getopt()其实就是对命令行参数解析的函数， 同时也可以解析多个选项，like this：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ffo@debian:~/Cprogramme$ ./<span class="selector-tag">a</span><span class="selector-class">.out</span> -<span class="selector-tag">i</span> -f <span class="string">&quot;1121&quot;</span> -<span class="selector-tag">a</span></span><br><span class="line">Option: <span class="selector-tag">i</span></span><br><span class="line">Filename: <span class="number">1121</span></span><br><span class="line">./<span class="selector-tag">a</span><span class="selector-class">.out</span>: invalid option -- <span class="string">&#x27;a&#x27;</span></span><br><span class="line">Usage: ./<span class="selector-tag">a</span><span class="selector-class">.out</span> <span class="selector-attr">[-ilr]</span> <span class="selector-attr">[-f filename]</span> args</span><br></pre></td></tr></table></figure>

<p>我们也可以修改源文件查看optind, oprerr的值：<br>在打印选项之前添加一行代码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;optind: %d &quot;</span>, optind);</span><br></pre></td></tr></table></figure>
<p>在打印错误消息前添加一行</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;optind: %d opterr: %d &quot;</span>, optind, opterr);</span><br></pre></td></tr></table></figure>
<p>再次执行得到：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"> ./<span class="selector-tag">a</span><span class="selector-class">.out</span> -<span class="selector-tag">i</span> -l -f</span><br><span class="line">optind: <span class="number">2</span> Option: <span class="selector-tag">i</span></span><br><span class="line">optind: <span class="number">3</span> Option: l</span><br><span class="line">./<span class="selector-tag">a</span><span class="selector-class">.out</span>: option requires an argument -- <span class="string">&#x27;f&#x27;</span></span><br><span class="line">Usage: ./<span class="selector-tag">a</span><span class="selector-class">.out</span> <span class="selector-attr">[-ilr]</span> <span class="selector-attr">[-f filename]</span> args</span><br><span class="line">optind: <span class="number">4</span> opterr: <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>其中有个小问题，我们明明在打印错误消息前先打印了optind，opterr的值，但是为什么记过出来之后却是先打印错误消息在打印这两个变量的值， 这是因为当遇到需要参数但未提供参数的选项（例如 -f）时，getopt 函数的行为会因 opterr 的值而有所不同。在大多数环境中，默认情况下 opterr 被设置为 1，这意味着 getopt 会自动打印错误信息到标准错误输出（stderr）。</p>
<p>这条消息是由 getopt 函数自动产生的，因为 -f 选项缺少必需的参数。在打印了错误消息之后，getopt 函数返回 ‘?’，导致程序执行 case ‘?’ 分支。在这个分支中，尝试打印 optind 和 opterr 的值。</p>
<p>但是，由于错误消息已经被 getopt 自动打印出来了（在进入 case ‘?’ 分支之前），所以看起来像是 Usage 信息和 optind: 2 opterr: 1 的打印顺序颠倒了。</p>
<blockquote>
<h4 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long()"></a>getopt_long()</h4></blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getopt_long</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span> *optstring,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="keyword">struct</span> option *longopts,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> *longindex)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数比getopt()多加了两个参数， 但是原先的参数还是同样的作用。</p>
<p><code>const struct option *longopts</code>： 指向 option 结构的数组，每个元素定义了一个长选项，包括选项的名称、是否需要参数、一个返回值的指针和短选项字符。数组的最后一个元素必须是全零，作为终结符。</p>
<p><code>int *longindex</code>: 如果非 NULL，getopt_long 将在此处存储 longopts 数组中当前找到的选项的索引。</p>
<h4 id="option-结构定义"><a href="#option-结构定义" class="headerlink" title="option 结构定义"></a>option 结构定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">option</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// 长选项名称</span></span><br><span class="line">    <span class="type">int</span> has_arg;      <span class="comment">// 选项是否需要参数：no_argument（0）、required_argument（1）或 optional_argument（2）</span></span><br><span class="line">    <span class="type">int</span> *flag;        <span class="comment">// 如果非 NULL，getopt_long 返回 0，而 *flag 设置为 val 的值；如果 NULL，getopt_long 返回 val</span></span><br><span class="line">    <span class="type">int</span> val;          <span class="comment">// 与选项相关的值；如果 flag 非 NULL，val 是 *flag 的值，否则 val 是 getopt_long 的返回值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> digit_optind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">option</span> long_options[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;add&quot;</span>, required_argument, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;append&quot;</span>, no_argument, <span class="number">0</span>, <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;delete&quot;</span>, required_argument, <span class="number">0</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;verbose&quot;</span>, no_argument, <span class="number">0</span>, <span class="string">&#x27;v&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;create&quot;</span>, required_argument, <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;file&quot;</span>, required_argument, <span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> option_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        c = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;abc:d:vf:&quot;</span>, long_options, &amp;option_index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Option %c\n&quot;</span>, c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Option %c with argument &#x27;%s&#x27;\n&quot;</span>, c, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;?? getopt returned character code 0%o ??\n&quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optind &lt; argc) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non-option ARGV-elements: &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (optind &lt; argc)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, argv[optind++]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后会发现：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -a</span><br><span class="line"><span class="title class_">Option</span> a</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -f <span class="string">&quot;12121&quot;</span></span><br><span class="line"><span class="title class_">Option</span> f <span class="keyword">with</span> argument <span class="string">&#x27;12121&#x27;</span></span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out -add</span><br><span class="line"><span class="title class_">Option</span> a</span><br><span class="line"><span class="title class_">Option</span> d <span class="keyword">with</span> argument <span class="string">&#x27;d&#x27;</span></span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out --add</span><br><span class="line">./<span class="symbol">a.out:</span> option <span class="string">&#x27;--add&#x27;</span> requires an argument</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out --add <span class="string">&quot;12121&quot;</span></span><br><span class="line"><span class="title class_">Option</span> a</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out --verbose</span><br><span class="line"><span class="title class_">Option</span> v</span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span></span><br></pre></td></tr></table></figure>
<p>现在我们无论用短选项还是长选项都可以正确解析。</p>
]]></content>
      <categories>
        <category>C/CPP</category>
      </categories>
      <tags>
        <tag>C/CPP C函数</tag>
      </tags>
  </entry>
  <entry>
    <title>oatpp的初步探索</title>
    <url>/2025/02/17/oatpp%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><p>CORS(跨域资源共享)：浏览器的安全特性，允许你控制哪些外部域名访问你的API</p>
<p>API路由：简单来说就是根据客户端发起的请求（包括请求的方法，如GET、POST、PUT等，以及请求的URL路径）将请求映射到不同的处理逻辑中：</p>
<p>1.匹配客户端发来的请求</p>
<p>2.根据请求的路径和方法，找到并执行相应的代码（处理逻辑）</p>
<p>3.返回一个响应给客户端</p>
<span id="more"></span>

<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="function">Declare Endpoint</span></span><br><span class="line"><span class="function"><span class="title">ENDPOINT</span><span class="params">(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;/users/&#123;userId&#125;&quot;</span>, putUser,</span></span></span><br><span class="line"><span class="params"><span class="function">         PATH(Int64, userId),</span></span></span><br><span class="line"><span class="params"><span class="function">         BODY_DTO(Object&lt;UserDto&gt;, userDto))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  userDto-&gt;id = userId;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">createDtoResponse</span>(Status::CODE_200, m_database-&gt;<span class="built_in">updateUser</span>(userDto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本段代码的作用是声明一个HTTP请求的API路由：</p>
<ul>
<li><code>put</code>: 说明这是一个HTTP PUT请求, 用于更新资源</li>
<li><code>/users/&#123;userId&#125;</code>: 定义了API的路径，其中{userId}表示特定的用户，用来定位特定用户</li>
<li><code>putUser</code>： 处理该请求的函数或者方法</li>
<li><code>PATH(Int64, userId)</code>: ；将路径中提取的参数userId绑定到Int64类型的userId变量中</li>
<li><code>BODY_DTO(Object&lt;UserDto&gt;, userDto)</code>: 请求体中的数据会被反序列化为一个UserDto对象，并包装在Object<UserDto>类型中。可以通过userDto访问请求体中的数据并进行处理，Object<T>是oatpp框架中的一个智能指针类型</li>
</ul>
<p>我们可以从<a href="https://oatpp.io/docs/components/api-controller/#declaration">这里</a>得到ENDPOINT宏的参数说明和用法</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ENDPOINT</span><span class="params">(<span class="string">&quot;&lt;http-method&gt;&quot;</span>, <span class="string">&quot;&lt;path&gt;&quot;</span>, &lt;method-name&gt;, &lt;optional param-mappings&gt;)</span></span></span><br></pre></td></tr></table></figure>

<p>当然你也可以直接在源码中找到ENDPOINT的定义：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"> * Codegen macro <span class="keyword">to</span> be used <span class="keyword">in</span> `oatpp::web::server::api::ApiController` <span class="keyword">to</span> generate Endpoint.</span><br><span class="line"> * @param <span class="keyword">METHOD</span> - <span class="title function_">Http</span> <span class="title function_">method</span> <span class="params">(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, etc.)</span>.</span><br><span class="line"> * @<span class="title function_">param</span> <span class="title function_">PATH</span> - <span class="title function_">Path</span> <span class="title function_">to</span> <span class="title function_">endpoint</span> <span class="params">(without host)</span>.</span><br><span class="line"> * @<span class="title function_">param</span> <span class="title function_">NAME</span> - <span class="title function_">Name</span> <span class="title function_">of</span> <span class="title function_">the</span> <span class="title function_">generated</span> <span class="title function_">method</span>.</span><br><span class="line"> * @<span class="title function_">return</span> - <span class="title function_">std</span>::shared_ptr <span class="keyword">to</span> &amp;id:oatpp::web::protocol::http::outgoing::Response<span class="punctuation">;</span>.</span><br><span class="line"> */</span><br><span class="line">#define ENDPOINT(<span class="keyword">METHOD</span>, <span class="title function_">PATH</span>, ...) \</span><br><span class="line"><span class="title function_">OATPP_MACRO_EXPAND</span><span class="params">(OATPP_MACRO_MACRO_BINARY_SELECTOR(OATPP_MACRO_API_CONTROLLER_ENDPOINT_MACRO_, (__VA_ARGS__)</span>) <span class="params">(<span class="keyword">METHOD</span>, PATH, __VA_ARGS__)</span>)</span><br></pre></td></tr></table></figure>

<p>这个宏定义一个HTTP endpoint，在<code>ApiController</code>中处理不同的HTTP方法，根据提供的HTTP方法和路径，利用多重宏选择机制和宏展开来生成适合的代码</p>
]]></content>
      <categories>
        <category>C/CPP</category>
      </categories>
      <tags>
        <tag>oatpp C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map的排序</title>
    <url>/2024/05/18/unordered-map%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="unordered-map-的排序"><a href="#unordered-map-的排序" class="headerlink" title="unordered_map 的排序"></a>unordered_map 的排序</h1><p><code>unordered_map</code>是C++的哈希表结构， <code>unorded_map</code>并不能直接排序， 如果要排序，一般来说需要将<code>unordered_map</code>转换为<code>vector</code>再通过自定义排序函数使用<code>sort</code>进行排序。</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a.second &gt; b.second;   <span class="comment">// 按照second降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_unordered_map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">      mp[c] = idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 利用vector构造函数快速转换</span></span><br><span class="line">   vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">sorted_mp</span>(mp.<span class="built_in">begin</span>(), mp.<span class="built_in">end</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">sort</span>(sorted_mp.<span class="built_in">begin</span>(), sorted_mp.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 此时可以选择直接使用排序后的vector或者再转换为哈希表</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> [a, b] : sorted_mp) &#123;</span><br><span class="line">      cout &lt;&lt; a &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>





<blockquote>
<p>关于<code>sort</code>函数：</p>
<p>默认函数有两种，第一个参数和第二个参数都是容器的起始地址和结束地址，第三个参数是排序函数，接受范围内的两个元素作为参数并返回可转换为布尔值的二元函数。返回的值表示作为第一个参数传递的元素是否被视为在其定义的特定严格弱排序中位于第二个参数之前。</p>
<table>
<thead>
<tr>
<th><code>template &lt;class RandomAccessIterator&gt;  void sort (RandomAccessIterator first, RandomAccessIterator last);</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>template &lt;class RandomAccessIterator, class Compare&gt;  void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></td>
</tr>
</tbody></table>
<p><code>sort</code>对于不同类型的默认排序：</p>
<p>对数组排序： 默认从小到大排序</p>
<p>对<code>pair</code>排序，默认对first从小到大排序，first相同是对second从小到大排序</p>
<p>对结构体： 一般需要自定义函数</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/CPP 数据结构 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2024/04/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>二叉树的知识每次用都要重新复习一遍，所以索性写一篇博客加强记忆</p>
</blockquote>
<p>二叉树的遍历有四种方式：前序遍历、中序遍历、后续遍历、层序遍历，下面主要通过递归和显式栈的方式来实现前中后序遍历， 层序遍历使用队列实现</p>
<p>前中后序遍历可以简便的记为： ‘中’的位置，即</p>
<p>​	前序遍历为：中左右</p>
<p>​	中序遍历为：左中右</p>
<p>​	后续遍历为：左右中</p>
<span id="more"></span>


<h2 id="0-二叉树的定义"><a href="#0-二叉树的定义" class="headerlink" title="0.二叉树的定义"></a>0.二叉树的定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">   T val;</span><br><span class="line">   TreeNode* left;</span><br><span class="line">   TreeNode* right;</span><br><span class="line">   <span class="built_in">TreeNode</span>(T val): <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h2><blockquote>
<p>前序遍历笼统来讲就是先访问根节点，再访问根节点的左子树，最后访问根节点的右子树</p>
<p>具体规则如下：</p>
<ul>
<li>如果根节点为空，则返回</li>
<li>如果根节点不为空：<ol>
<li>访问根节点</li>
<li>以前序遍历的方式访问左子树</li>
<li>以前序遍历的方式访问右子树</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="/2024/04/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/preorder.png" alt="img"></p>
<h3 id="1-1-前序遍历的递归实现"><a href="#1-1-前序遍历的递归实现" class="headerlink" title="1.1 前序遍历的递归实现"></a>1.1 前序遍历的递归实现</h3><p>步骤：</p>
<ol>
<li>判断根结点是否为空， 为空则返回</li>
<li>访问根节点</li>
<li>递归遍历左子树</li>
<li>递归遍历右子树</li>
</ol>
<p>递归代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode&lt;<span class="type">int</span>&gt;* root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">   <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">   <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析： 每个节点只会被访问一次，即<em>O</em>(<em>n</em>)， 其中n是树中节点的数量</p>
<p>空间复杂度分析： 递归的空间复杂度取决于树的高度，最坏情况下（完全不平衡的树）可以达到<em>O</em>(<em>n</em>)，其中n是树的节点数。对于平衡树，空间复杂度为<em>O</em>(<em>log n</em>)。</p>
<h3 id="1-2-前序遍历的显式栈实现"><a href="#1-2-前序遍历的显式栈实现" class="headerlink" title="1.2 前序遍历的显式栈实现"></a>1.2 前序遍历的显式栈实现</h3><p>显式栈即使用栈来模拟递归的过程</p>
<p>前序遍历的顺序为：根节点 - 左子树 - 右子树， 根据栈的特点， 入栈的顺序为: 右子树 - 左子树 - 根节点</p>
<p>步骤：</p>
<ol>
<li>判断根节点时候为空， 为空则返回</li>
<li>初始化维护一个栈，将根节点入栈</li>
<li>当栈不为空时：<ol>
<li>弹出并访问栈顶元素</li>
<li>当node右子树不为空，将右子树入栈</li>
<li>当node左子树不为空，将左子树入栈</li>
</ol>
</li>
</ol>
<p>显式栈的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(TreeNode&lt;<span class="type">int</span>&gt;* root)</span> </span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">   stack&lt;TreeNode&lt;<span class="type">int</span>&gt;*&gt; st;</span><br><span class="line">   st.<span class="built_in">push</span>(root);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      TreeNode&lt;<span class="type">int</span>&gt;* node = st.<span class="built_in">top</span>();</span><br><span class="line">      res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">      <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：与递归相同， 每个节点只会被访问一次，即<em>O</em>(<em>n</em>)， 其中n是树中节点的数量</p>
<p>空间复杂度分析：理论上与递归相同，但在实践中，因为手动管理栈，有时可以通过优化减少空间使用。</p>
<h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h2><blockquote>
<p>中序遍历简单来说就是先访问根节点的左子树，再访问根节点，最后访问根节点的右子树</p>
<p>具体规则如下：</p>
<ol>
<li>如果root为空则返回</li>
<li>如果root非空：<ol>
<li>中序遍历根节点左子树</li>
<li>访问根节点</li>
<li>中序遍历根节点右子树</li>
</ol>
</li>
</ol>
</blockquote>
<p><img src="/2024/04/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/inorder.png" alt="img"></p>
<p>因为中序遍历的顺序是左中右，所以如果二叉树是搜索树， 可以利用中序遍历来验证</p>
<h3 id="2-1-中序遍历的递归实现"><a href="#2-1-中序遍历的递归实现" class="headerlink" title="2.1 中序遍历的递归实现"></a>2.1 中序遍历的递归实现</h3><p>步骤：</p>
<ol>
<li>判断根结点是否为空， 为空则返回</li>
<li>递归遍历左子树</li>
<li>访问根节点</li>
<li>递归遍历右子树</li>
</ol>
<p>递归代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;<span class="type">int</span>&gt;* root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(root-&gt;left) <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">   res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">   <span class="keyword">if</span>(root-&gt;right) <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析： <em>O</em>(<em>n</em>)，同前序遍历</p>
<p>空间复杂度分析：同前序遍历</p>
<h3 id="2-2-中序遍历的显式栈实现"><a href="#2-2-中序遍历的显式栈实现" class="headerlink" title="2.2 中序遍历的显式栈实现"></a>2.2 中序遍历的显式栈实现</h3><p>因为是递归的显式栈实现，所以会比较难理解。</p>
<p>与前序遍历不同，访问根节点要放在左子树遍历完之后。因此我们需要保证：<strong>在左子树访问之前，当前节点不能提前出栈</strong>。</p>
<p>我们应该从根节点开始，循环遍历左子树，不断将当前子树的根节点放入栈中，直到当前节点无左子树时，从栈中弹出该节点并进行处理。</p>
<p>然后再访问该元素的右子树，并进行上述循环遍历左子树的操作。这样可以保证最终遍历顺序为中序遍历顺序。</p>
<p>二叉树的中序遍历显式栈实现步骤如下：</p>
<ol>
<li>判断二叉树是否为空，为空则直接返回。</li>
<li>初始化维护一个空栈。</li>
<li>当根节点或者栈不为空时：<ol>
<li>如果当前节点不为空，则循环遍历左子树，并不断将当前子树的根节点入栈。</li>
<li>如果当前节点为空，说明当前节点无左子树，则弹出栈顶元素<em>node</em>，并访问该元素，然后尝试访问该节点的右子树。</li>
</ol>
</li>
</ol>
<p>迭代代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(TreeNode&lt;<span class="type">int</span>&gt;* root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">   stack&lt;TreeNode&lt;<span class="type">int</span>&gt;*&gt; st;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(root || st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span>(root) &#123;</span><br><span class="line">         st.<span class="built_in">push</span>(root);</span><br><span class="line">         root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      TreeNode&lt;<span class="type">int</span>&gt;* node = st.<span class="built_in">top</span>();</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">      res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">      root = node-&gt;right;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h2><blockquote>
<ul>
<li>如果二叉树为空，则返回。</li>
<li>如果二叉树不为空，则：</li>
</ul>
<ol>
<li>以后序遍历的方式遍历根节点的左子树。</li>
<li>以后序遍历的方式遍历根节点的右子树。</li>
<li>访问根节点。</li>
</ol>
</blockquote>
<p><img src="/2024/04/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/postorder.png" alt="img"></p>
<h3 id="3-1-后序遍历递归实现"><a href="#3-1-后序遍历递归实现" class="headerlink" title="3.1 后序遍历递归实现"></a>3.1 后序遍历递归实现</h3><p>二叉树的后序遍历递归实现步骤为：</p>
<ol>
<li>判断二叉树是否为空，为空则直接返回。</li>
<li>先递归遍历左子树。</li>
<li>然后递归遍历右子树。</li>
<li>最后访问根节点。</li>
</ol>
<p>二叉树的后序遍历递归实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode&lt;<span class="type">int</span>&gt;* root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(root-&gt;left) <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">   <span class="keyword">if</span>(root-&gt;right) <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">   res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-后序遍历显式栈实现"><a href="#3-2-后序遍历显式栈实现" class="headerlink" title="3.2 后序遍历显式栈实现"></a>3.2 后序遍历显式栈实现</h3><p>不同于前两个遍历, 后续遍历需要保证: 再访问完根节点的左右两颗子树前, 不能访问根节点.</p>
<p>所以我们需要先遍历到最左边的节点, 然后访问判断其右子树是否存在或者已经访问过, 如果不存在或者访问过, 那么就访问根节点,否则访问右子树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorder</span><span class="params">(TreeNode&lt;<span class="type">int</span>&gt;* root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">   stack&lt;TreeNode&lt;<span class="type">int</span>&gt;*&gt; st;</span><br><span class="line">   TreeNode&lt;<span class="type">int</span>&gt;* prev;       </span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(root || st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span>(root) &#123;</span><br><span class="line">         st.<span class="built_in">push</span>(root);</span><br><span class="line">         root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      TreeNode&lt;<span class="type">int</span>&gt;* node = st.<span class="built_in">top</span>();</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!node-&gt;right || prev == node-&gt;right) &#123;</span><br><span class="line">         res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">         prev = node;</span><br><span class="line">         root = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         st.<span class="built_in">push</span>(node);</span><br><span class="line">         root = node-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4.层序遍历"></a>4.层序遍历</h2><blockquote>
<p>层序遍历顾名思义， 就是按照树的层数一层一层遍历，一般采用双向队列实现</p>
<p>层序遍历规则如下：</p>
<ol>
<li>如果二叉树为空则返回</li>
<li>如果二叉树不为空:<ol>
<li>访问第一层的节点</li>
<li>访问第二层的节点</li>
<li>…</li>
<li>访问最后一层的节点</li>
</ol>
</li>
</ol>
</blockquote>
<p><img src="/2024/04/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/levelorder.png" alt="img"></p>
<h3 id="4-1-层序遍历的队列实现"><a href="#4-1-层序遍历的队列实现" class="headerlink" title="4.1 层序遍历的队列实现"></a>4.1 层序遍历的队列实现</h3><p>按照上面的规则我们很容易实现代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelorder</span>(TreeNode&lt;<span class="type">int</span>&gt;* root) &#123;</span><br><span class="line">   vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">   <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   queue&lt;TreeNode&lt;<span class="type">int</span>&gt;*&gt; q;</span><br><span class="line">   q.<span class="built_in">push</span>(root);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">      <span class="type">int</span> len = q.<span class="built_in">size</span>();        <span class="comment">// 队列保存当前层的节点, 所以len是当前层节点的数量</span></span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; tmp;           <span class="comment">// 存放当前层节点的值</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;      <span class="comment">// 只处理当前层的节点</span></span><br><span class="line">         TreeNode&lt;<span class="type">int</span>&gt;* node = q.<span class="built_in">front</span>();    <span class="comment">// 取出队头元素处理</span></span><br><span class="line">         q.<span class="built_in">pop</span>();                            <span class="comment">// 删除队头元素</span></span><br><span class="line">         tmp.<span class="built_in">push_back</span>(node-&gt;val);           <span class="comment">// 访问队头元素</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 如果左节点不为空, 把左节点入队</span></span><br><span class="line">         <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">      res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>【文章】<a href="https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/">二叉树的遍历知识</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实机安装Anolis的坑及安装之后的网络修复</title>
    <url>/2025/01/06/%E5%AE%89%E8%A3%85Anolis%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>前两天突发奇想想把一直在用的实机(Debian 12)换成Anolis OS,在安装这个系统的时候碰到了不少问题,现记录于此.</p>
<blockquote>
<h3 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置:"></a>机器配置:</h3><p><strong>笔记本品牌:</strong> HUAWEI MateBook D 14</p>
</blockquote>
<p><strong>CPU型号:</strong> R5 4500U</p>
<p><strong>内存:</strong> DDR4 16GB 2666MHz</p>
<p><strong>硬盘:</strong> SSD 512GB </p>
<p><strong>网络通信:</strong> Realtek RTL8821CE&#x2F;RTL8822CE Wi-Fi</p>
<blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><p><strong>准备:</strong> 至少16GB的U盘</p>
</blockquote>
<ol>
<li><p>从<a href="https://openanolis.cn/">Anolis官网</a>下载需要的镜像</p>
</li>
<li><p>通过u盘刻录软件将镜像刻录到U盘(我用的是rufus), 其中刻录的时候要注意的是: </p>
<p> 1.分区类型(MBR或GPT)一定要选择与系统相匹配的类型, MateBook D 14要选择GPT,不然会导致启动u盘的时候被验证失败(Error: Vertification failed).</p>
<p> 2.写入模式要选择DD模式, 不要选择ISO模式, 不然会导致进入安装界面的时候本地仓库识别不到.</p>
</li>
<li><p>最后根据引导完成安装即可.</p>
<span id="more"></span></li>
</ol>
<blockquote>
<h3 id="网络修复"><a href="#网络修复" class="headerlink" title="网络修复"></a>网络修复</h3><p>由于本系统的网卡是Realtek RTL8821CE&#x2F;RTL8822CE Wi-Fi, 在安装完Anolis OS系统后会出现网卡驱动无法加载的问题, 进入官网后发现Realtek官网并没有提供Linux系统的RTL8821CE&#x2F;RTL8822CE Wi-Fi网卡驱动, 在网上搜索之后我发现了一个可以修复问题的方法:</p>
</blockquote>
<p>西班牙大神做的一个RTL8822CE Wi-Fi网卡驱动(<a href="https://github.com/juanro49/rtl88x2ce-dkms">github页面</a>), 但是作者只提供了.deb版本, 并没有.rpm版本, 但是我们可以从源码编译安装:</p>
<ol>
<li>从其他设备到github页面下载驱动.</li>
<li>通过u盘拷贝到本系统, <strong>注意: Anolis OS系统缺少对NTFS文件系统的支持, 因此无法挂在NTFS格式的U盘, 所以最好使用FAT32格式的U盘.</strong></li>
<li>通过以下指令安装驱动:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将配置文件复制到/etc/modprobe.d/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> rtl88x2ce-dkms/rtw88_blacklist.conf /etc modprobe.d/rtw88_blacklist.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建源码目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> /usr/src/rtl88x2ce-35403</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制驱动源码文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> -Rv rtl88x2ce-dkms/* /usr/src/rtl88x2ce-35403/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译并安装驱动</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/src/rtl88x2ce-35403</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加载模块</li>
</ol>
<p><code>$ sudo modprobe 88x2ce</code></p>
<ol start="5">
<li>重启并检查是否可以使用</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Anolis</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析C语言中的main函数</title>
    <url>/2024/02/27/%E6%B5%85%E6%9E%90C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84main%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a><a href="https://cloud.tencent.com/developer/article/1758808">原文</a></h3></blockquote>
<blockquote>
<p>some notes:</p>
</blockquote>
<p>返回值: main()的返回值应该是int, 而不是void. 虽然在一些编译器中，void main()可以通过编译，但并非所有编译器都支持 void main()，因为标准中从来没有定义过 void main 。</p>
<p>main返回值类型：<br><img src="/2024/02/27/%E6%B5%85%E6%9E%90C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84main%E5%87%BD%E6%95%B0/image.png" alt="main返回值类型"></p>
<blockquote>
<p>main()函数传参</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[],<span class="type">char</span>* envp[])</span></span>; </span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>①、第一个参数argc表示的是传入参数的个数 。</p>
<p>②、第二个参数char* argv[]，是字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：</p>
<p>argv[0]：指向程序运行的全路径名。</p>
<p>argv[1]：指向执行程序名后的第一个字符串 ，表示真正传入的第一个参数。</p>
<p>argv[2]：指向执行程序名后的第二个字符串 ，表示传入的第二个参数。</p>
<p>……argv[n]：指向执行程序名后的第n个字符串 ，表示传入的第n个参数。</p>
<p>规定：argv[argc]为NULL ，表示参数的结尾。</p>
<span id="more"></span>


<p>③、第三个参数char* envp[]，也是一个字符串数组，主要是保存这用户环境中的变量字符串，以NULL结束。envp[]的每一个元素都包含ENVVAR&#x3D;value形式的字符串，其中ENVVAR为环境变量，value为其对应的值。</p>
<p>envp一旦传入，它就只是单纯的字符串数组而已，不会随着程序动态设置发生改变。可以使用putenv函数实时修改环境变量，也能使用getenv实时查看环境变量，但是envp本身不会发生改变；平时使用到的比较少。</p>
<p>注意：main函数的参数char* argv[]和char* envp[]表示的是字符串数组，书写形式不止char* argv[]这一种，相应的argv[][]和char** argv均可。</p>
<h4 id="对main-函数传参"><a href="#对main-函数传参" class="headerlink" title="对main()函数传参"></a>对main()函数传参</h4><p>格式： 可执行文件名 参数1 参数2 … … 参数n<br>eg:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>gcc testmain.c </span><br><span class="line">ffo<span class="variable">@debian</span><span class="symbol">:~/Cprogramme</span><span class="variable">$ </span>./a.out <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>main()的执行顺序</p>
</blockquote>
<p>linux系统下程序的入口是”_start”，这个函数是linux系统库（Glibc）的一部分，当我们的程序和Glibc链接在一起形成最终的可执行文件的之后，这个函数就是程序执行初始化的入口函数。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">_start:</span></span><br><span class="line"> <span class="keyword">xor</span> <span class="built_in">ebp</span>, <span class="built_in">ebp</span> //清空<span class="built_in">ebp</span></span><br><span class="line"> <span class="keyword">pop</span> <span class="built_in">esi</span> //保存argc，<span class="built_in">esi</span> = argc</span><br><span class="line"> <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="built_in">ecx</span> //保存argv, <span class="built_in">ecx</span> = argv</span><br><span class="line"></span><br><span class="line"> <span class="keyword">push</span> <span class="built_in">esp</span> //参数<span class="number">7</span>保存当前栈顶</span><br><span class="line"> <span class="keyword">push</span> <span class="built_in">edx</span> //参数<span class="number">6</span></span><br><span class="line"> <span class="keyword">push</span> __libc_csu_fini//参数<span class="number">5</span></span><br><span class="line"> <span class="keyword">push</span> __libc_csu_init//参数<span class="number">4</span></span><br><span class="line"> <span class="keyword">push</span> <span class="built_in">ecx</span> //参数<span class="number">3</span></span><br><span class="line"> <span class="keyword">push</span> <span class="built_in">esi</span> //参数<span class="number">2</span></span><br><span class="line"> <span class="keyword">push</span> main//参数<span class="number">1</span></span><br><span class="line"> <span class="keyword">call</span> _libc_start_main</span><br><span class="line"></span><br><span class="line"><span class="keyword">hlt</span></span><br></pre></td></tr></table></figure>

<p>所以在main()函数执行前还要做一系列的工作， 主要是初始化系统相关资源：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Some <span class="keyword">of</span> <span class="keyword">the</span> stuff <span class="keyword">that</span> has <span class="keyword">to</span> happen <span class="keyword">before</span> main():</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> up initial stack pointer </span><br><span class="line"></span><br><span class="line">initialize static <span class="keyword">and</span> <span class="keyword">global</span> data </span><br><span class="line"></span><br><span class="line">zero out uninitialized data </span><br><span class="line"></span><br><span class="line"><span class="built_in">run</span> <span class="keyword">global</span> constructors</span><br><span class="line"></span><br><span class="line">Some <span class="keyword">of</span> this comes <span class="keyword">with</span> <span class="keyword">the</span> runtime library&#x27;s crt0.o <span class="built_in">file</span> <span class="keyword">or</span> <span class="keyword">its</span> __start() function. Some <span class="keyword">of</span> <span class="keyword">it</span> you need <span class="keyword">to</span> do yourself.</span><br><span class="line"></span><br><span class="line">Crt0 <span class="keyword">is</span> a synonym <span class="keyword">for</span> <span class="keyword">the</span> C runtime library.</span><br></pre></td></tr></table></figure>

<p>在main函数执行前的函数：</p>
<p>（1）全局对象的构造函数会在main 函数之前执行。</p>
<p>（2）一些全局变量、对象和静态变量、对象的空间分配和赋初值就是在执行main函数之前，而main函数执行完后，还要去执行一些诸如释放空间、释放资源使用权等操作</p>
<p>（3）进程启动后，要执行一些初始化代码（如设置环境变量等），然后跳转到main执行。全局对象的构造也在main之前。</p>
<p>（4）通过关键字attribute，让一个函数在主函数之前运行，进行一些数据初始化、模块加载验证等。</p>
<p>作者：z_ryan</p>
<p>原文：<a href="https://blog.csdn.net/z_ryan/category_7316855.html">https://blog.csdn.net/z_ryan/category_7316855.html</a></p>
<p>免责声明：本文来源网络，免费传达知识，版权归原作者所有。如涉及作品版权问题，请联系我进行删除。</p>
]]></content>
      <categories>
        <category>C/CPP</category>
      </categories>
      <tags>
        <tag>C/CPP C函数</tag>
      </tags>
  </entry>
  <entry>
    <title>类Unix系统中进程的标准的文件描述符</title>
    <url>/2024/03/15/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>文件描述符在Unix系统中是一个整数，用来标识打开的文件或者I&#x2F;O资源，每个进程默认会打开三个标准文件描述符（File Descriptors, FDs），用于处理输入和输出。下面介绍这三个FD</p>
<ol>
<li><strong>标准输入（Standard Input）</strong><ul>
<li><strong>文件描述符编号</strong>：<code>0</code></li>
<li><strong>作用</strong>：用于进程读取输入数据（默认来自键盘输入）</li>
<li><strong>相关符号</strong>：在Shell中通常用 <code>&lt;</code> 或 <code>&lt;&lt;</code> 进行重定向（如 <code>command &lt; input.txt</code>）</li>
</ul>
</li>
<li><strong>标准输出（Standard Output）</strong><ul>
<li><strong>文件描述符编号</strong>：<code>1</code></li>
<li><strong>作用</strong>：用于进程输出正常结果（默认显示到终端）</li>
<li><strong>相关符号</strong>：在Shell中通常用 <code>&gt;</code> 或 <code>&gt;&gt;</code> 进行重定向（如 <code>command &gt; output.txt</code>）</li>
</ul>
</li>
<li><strong>标准错误（Standard Error）</strong><ul>
<li><strong>文件描述符编号</strong>：<code>2</code></li>
<li><strong>作用</strong>：用于输出错误或诊断信息（默认显示到终端）</li>
<li><strong>相关符号</strong>：在Shell中用 <code>2&gt;</code> 或 <code>2&gt;&gt;</code> 重定向错误（如 <code>command 2&gt; error.txt</code>）</li>
</ul>
</li>
</ol>
<p>​<span id="more"></span>	</p>
<p>那我们在看以下代码便会清晰的多：</p>
<p><code>echo log &gt; /dev/null 2&gt;&amp;1</code></p>
<p>这条命令由以下部分组成：</p>
<ul>
<li>**<code>echo log</code>**：向标准输出（stdout）打印字符串 <code>log</code></li>
<li>**<code>&gt; /dev/null</code>**：将标准输出（文件描述符 <code>1</code>）重定向到 <code>/dev/null</code></li>
<li>**<code>2&gt;&amp;1</code>**：将标准错误（文件描述符 <code>2</code>）重定向到当前标准输出（即 <code>/dev/null</code>）</li>
</ul>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a><strong>关键概念</strong></h3><h4 id="1-dev-null-的作用"><a href="#1-dev-null-的作用" class="headerlink" title="(1) /dev/null 的作用"></a><strong>(1) <code>/dev/null</code> 的作用</strong></h4><ul>
<li><code>/dev/null</code> 是一个特殊的设备文件，写入它的内容会被直接丢弃</li>
<li>常用于屏蔽命令的输出或错误信息</li>
</ul>
<h4 id="2-文件描述符重定向"><a href="#2-文件描述符重定向" class="headerlink" title="(2) 文件描述符重定向"></a><strong>(2) 文件描述符重定向</strong></h4><ul>
<li><code>&gt;</code> 默认重定向标准输出（<code>1&gt;</code> 的简写）</li>
<li><code>2&gt;</code> 表示重定向标准错误（文件描述符 <code>2</code>）</li>
<li><code>&amp;1</code> 表示引用当前标准输出的目标（即 <code>/dev/null</code>）</li>
</ul>
<hr>
<h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a><strong>3. 执行流程</strong></h3><ol>
<li><strong><code>echo log</code> 输出内容</strong><br><code>echo</code> 命令默认将 <code>log</code> 写入标准输出（文件描述符 <code>1</code>）。</li>
<li><strong><code>&gt; /dev/null</code> 重定向标准输出</strong><br>将标准输出（<code>1</code>）从默认的终端屏幕重定向到 <code>/dev/null</code>，导致 <code>log</code> 被丢弃，不会显示在终端。</li>
<li><strong><code>2&gt;&amp;1</code> 重定向标准错误</strong><ul>
<li><code>2&gt;</code> 表示重定向标准错误（文件描述符 <code>2</code>）。</li>
<li><code>&amp;1</code> 表示将标准错误指向当前标准输出的目标（即 <code>/dev/null</code>）。</li>
<li>因此，标准错误（如有）也会被丢弃。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆化搜索求斐波那契数列的土亢</title>
    <url>/2024/06/12/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E5%9C%9F%E4%BA%A2/</url>
    <content><![CDATA[<blockquote>
<p>闲来无事刷个题目用所有方法解一遍斐波那契，没想到在记忆化翻车了</p>
</blockquote>
<p><b> 呆码 </b></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; mdfs = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(memo[i] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line"></span><br><span class="line">            memo[i] = <span class="built_in">mdfs</span>(i - <span class="number">1</span>) + <span class="built_in">mdfs</span>(i - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mdfs</span>(n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>看到代码通不过案例真的破防，检查了很多遍发现lambda函数没有问题，其他地方都看起来很河狸。</p>
<p>也问了gpt-4o, 同样没有给我正确的解释，对于gpt来说还是超前了嘛(黑人问号)</p>
<p>最后解决问题是因为这段代码只有<code>n = 0</code>时无法通过，所以我加代码又重试了两次， 都通过了，第一次是在函数开头加了<code>if (n &lt;= 1) return n;</code>第二次是将第4行的<code>memo[1] = 1;</code>改为<code>if(n &gt; 0) memo[1] = 1;</code></p>
<p>! 诶，立马意识到是memo数组出了问题, 所以将代码改了一个地方：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">10</span>, <span class="number">-1</span>)</span></span>;		<span class="comment">// 改为了n + 10, n == 0时memo数组长度只有1, 那么第4行的memo[1] = 1数组越界</span></span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; mdfs = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(memo[i] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line"></span><br><span class="line">            memo[i] = <span class="built_in">mdfs</span>(i - <span class="number">1</span>) + <span class="built_in">mdfs</span>(i - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mdfs</span>(n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此， 精神状态又美丽了几分。</p>
]]></content>
      <categories>
        <category>烂活大赏</category>
      </categories>
      <tags>
        <tag>烂活大赏 C/CPP 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>追踪一个main.c的周期</title>
    <url>/2024/03/14/%E8%BF%BD%E8%B8%AA%E4%B8%80%E4%B8%AAmain-c%E7%9A%84%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="使用strace工具追踪main-c的gcc编译过程及a-out的执行过程"><a href="#使用strace工具追踪main-c的gcc编译过程及a-out的执行过程" class="headerlink" title="使用strace工具追踪main.c的gcc编译过程及a.out的执行过程"></a>使用strace工具追踪main.c的gcc编译过程及a.out的执行过程</h3><blockquote>
<p>追踪gcc编译过程</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">strace</span> -o /dev/stdout gcc hello.c <span class="number">2</span>&gt;&amp;<span class="number">1</span> | vim -</span><br></pre></td></tr></table></figure>

<p>将strace追踪信息利用<code>|</code>(管道) 传递给vim, 这边要注意的是strace的输出是直接发送到标准错误输出<code>stderr</code>, 而不是标准输出<code>stdout</code>, 所以用<code>-o dev/stdout</code>将输出写到标准输出中， <code>2&gt;&amp;1</code>是将标准错误stderr（文件描述符2）重定向到标准输出stdout（文件描述符1）中， 详情见<a href="./%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.md">此处</a>. </p>
<span id="more"></span>

<p>那么我们可以得到这些信息：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/usr/bin/gcc&quot;</span>, [<span class="string">&quot;gcc&quot;</span>, <span class="string">&quot;hello.c&quot;</span>], <span class="number">0</span>x7ffde6f6a6e8 <span class="comment">/* 57 vars */</span>) = <span class="number">0</span></span><br><span class="line">brk(NULL)                               = <span class="number">0</span>x198a000</span><br><span class="line">mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7f1a6461f000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">newfstatat(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">94102</span>, ...&#125;, AT_EMPTY_PATH) = <span class="number">0</span></span><br><span class="line">mmap(NULL, <span class="number">94102</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f1a64608000</span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20t\2\0\0\0\0\0&quot;</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line">pread64(<span class="number">3</span>, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., <span class="number">784</span>, <span class="number">64</span>) = <span class="number">784</span></span><br><span class="line">newfstatat(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1922136</span>, ...&#125;, AT_EMPTY_PATH) = <span class="number">0</span></span><br><span class="line">pread64(<span class="number">3</span>, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., <span class="number">784</span>, <span class="number">64</span>) = <span class="number">784</span></span><br><span class="line">mmap(NULL, <span class="number">1970000</span>, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f1a64427000</span><br><span class="line">mmap(<span class="number">0</span>x7f1a6444d000, <span class="number">1396736</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>x26000) = <span class="number">0</span>x7f1a6444d000</span><br><span class="line">mmap(<span class="number">0</span>x7f1a645a2000, <span class="number">339968</span>, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>x17b000) = <span class="number">0</span>x7f1a645a2000</span><br><span class="line">mmap(<span class="number">0</span>x7f1a645f5000, <span class="number">2457</span>第<span class="number">1</span>段：程序启动和初始化（行<span class="number">1</span>-<span class="number">15</span>）</span><br><span class="line">解释：这一段描述了gcc编译器启动的初始步骤。execve系统调用用于执行gcc程序，后续的brk和mmap调用进行内存分配和管理，为程序的运行准备必要的资源。接着，通过openat和read系统调用，程序尝试访问和读取系统的动态链接器配置（/etc/ld.so.cache）和标准C库（libc.so.<span class="number">6</span>），这是程序运行前的必要准备，以确保能够正确链接到所需的共享库。</span><br><span class="line">第<span class="number">2</span>段：环境设置（行<span class="number">16</span>-<span class="number">27</span>）</span><br><span class="line">解释：程序继续进行环境设置，包括通过mmap为特定的数据结构分配更多内存，设置线程特定的数据（如arch_prctl调用设定线程的FS寄存器），并进行一些内存保护设置（mprotect调用）。这一部分的操作主要关注于为程序的执行和系统调用提供必要的环境配置。</span><br><span class="line">第<span class="number">3</span>段：本地化和错误消息处理（行<span class="number">28</span>-<span class="number">49</span>）</span><br><span class="line">解释：gcc尝试加载本地化支持文件，以便能够显示本地化的错误消息。通过一系列的openat调用搜索本地化文件，所有尝试均返回ENOENT（文件不存在），说明在指定的路径下没有找到相应的本地化文件。此外，ioctl调用的失败表明尝试获取终端属性未成功，这通常是因为gcc可能在没有终端的环境中运行（例如，脚本或其他自动化工具中）。</span><br><span class="line">第<span class="number">4</span>段：编译前的准备（行<span class="number">50</span>-<span class="number">95</span>）</span><br><span class="line">解释：这段涉及到编译前的准备工作，包括对信号处理的设置（如rt_sigaction调用），以确保在编译过程中能够正确处理诸如中断（SIGINT）和挂起（SIGHUP）等信号。接着，gcc进行一系列的路径和文件检查，确认编译器组件和工具链的位置（如查找gcc，cc1，以及相关库文件的位置）。这些步骤确保了编译过程可以找到所有必要的编译器组件和工具。</span><br><span class="line">第<span class="number">5</span>段：编译过程（行<span class="number">96</span>-<span class="number">204</span>）</span><br><span class="line">解释：这是实际编译过程的核心部分，涉及多个阶段，包括预处理、编译、汇编和链接。在这一段中，gcc生成了临时文件（如汇编代码文件），调用子进程（通过vfork和execve）来执行如cc1（gcc的编译器前端），汇编器（as），以及链接器（ld或collect2）。此外，通过pipe2和wait4等系统调用进行进程间通信和同步，确保编译过程按顺序进行。各种临时文件被创建和删除（unlink），是编译过程中间步骤的产物。</span><br><span class="line">第<span class="number">6</span>段：清理和退出（行<span class="number">205</span>-<span class="number">210</span>）</span><br><span class="line">解释：在编译任务完成后，gcc进行清理工作，包括删除临时文件，并最终通过exit_group系统调用退出程序。这表示编译过程已经全部完成，所有资源被适当地释放，gcc以返回状态码<span class="number">0</span>正常退出，标志着编译成功。, <span class="number">0</span>) = <span class="number">0</span>x7f1a645fb000</span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">mmap(NULL, <span class="number">12288</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7f1a64424000</span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0</span>x7f1a64424740) = <span class="number">0</span></span><br><span class="line">set_tid_address(<span class="number">0</span>x7f1a64424a10)         = <span class="number">16201</span></span><br><span class="line">set_robust_list(<span class="number">0</span>x7f1a64424a20, <span class="number">24</span>)     = <span class="number">0</span></span><br><span class="line">rseq(<span class="number">0</span>x7f1a64425060, <span class="number">0</span>x20, <span class="number">0</span>, <span class="number">0</span>x53053053) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0</span>x7f1a645f5000, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0</span>x539000, <span class="number">12288</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0</span>x7f1a64651000, <span class="number">8192</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">prlimit64(<span class="number">0</span>, RLIMIT_STACK, NULL, &#123;rlim_cur=<span class="number">8192</span>*<span class="number">1024</span>, rlim_max=RLIM64_INFINITY&#125;) = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0</span>x7f1a64608000, <span class="number">94102</span>)           = <span class="number">0</span></span><br><span class="line">getrandom(<span class="string">&quot;\xe0\xcb\x2e\x04\x26\xb5\x6a\x8e&quot;</span>, <span class="number">8</span>, GRND_NONBLOCK) = <span class="number">8</span></span><br><span class="line">brk(NULL)                               = <span class="number">0</span>x198a000</span><br><span class="line">brk(<span class="number">0</span>x19ab000)                          = <span class="number">0</span>x19ab000</span><br><span class="line">brk(<span class="number">0</span>x19cd000)                          = <span class="number">0</span>x19cd000</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/lib/locale/locale-archive&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">newfstatat(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">6209168</span>, ...&#125;, AT_EMPTY_PATH) = <span class="number">0</span></span><br><span class="line">mmap(NULL, <span class="number">6209168</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f1a63e00000</span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/locale.alias&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">newfstatat(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">2996</span>, ...&#125;, AT_EMPTY_PATH) = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;# Locale name alias data base.\n#&quot;</span>..., <span class="number">4096</span>) = <span class="number">2996</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">4096</span>)                       = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/en_US.UTF-8/LC_MESSAGES/gcc-12.mo&quot;</span>, O_RDONLY) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/en_US.utf8/LC_MESSAGES/gcc-12.mo&quot;</span>, O_RDONLY) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/en_US/LC_MESSAGES/gcc-12.mo&quot;</span>, O_RDONLY) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/en.UTF-8/LC_MESSAGES/gcc-12.mo&quot;</span>, O_RDONLY) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/en.utf8/LC_MESSAGES/gcc-12.mo&quot;</span>, O_RDONLY) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/usr/share/locale/en/LC_MESSAGES/gcc-12.mo&quot;</span>, O_RDONLY) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">ioctl(<span class="number">2</span>, TCGETS, <span class="number">0</span>x7ffea2eb7580)        = -<span class="number">1</span> ENOTTY (Inappropriate ioctl for device)</span><br><span class="line">ioctl(<span class="number">2</span>, TCGETS, <span class="number">0</span>x7ffea2eb7590)        = -<span class="number">1</span> ENOTTY (Inappropriate ioctl for device)</span><br><span class="line">ioctl(<span class="number">2</span>, TCGETS, <span class="number">0</span>x7ffea2eb7580)        = -<span class="number">1</span> ENOTTY (Inappropriate ioctl for device)</span><br><span class="line">rt_sigaction(SIGINT, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[INT], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_DFL, s<span class="built_in">a_mask</span>=[], s<span class="built_in">a_flags</span>=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGINT, &#123;s<span class="built_in">a_handler</span>=<span class="number">0</span>x4079b0, s<span class="built_in">a_mask</span>=[INT], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[INT], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGHUP, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[HUP], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_DFL, s<span class="built_in">a_mask</span>=[], s<span class="built_in">a_flags</span>=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGHUP, &#123;s<span class="built_in">a_handler</span>=<span class="number">0</span>x4079b0, s<span class="built_in">a_mask</span>=[HUP], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[HUP], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGTERM, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[TERM], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_DFL, s<span class="built_in">a_mask</span>=[], s<span class="built_in">a_flags</span>=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGTERM, &#123;s<span class="built_in">a_handler</span>=<span class="number">0</span>x4079b0, s<span class="built_in">a_mask</span>=[TERM], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[TERM], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGPIPE, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[PIPE], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_DFL, s<span class="built_in">a_mask</span>=[], s<span class="built_in">a_flags</span>=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGPIPE, &#123;s<span class="built_in">a_handler</span>=<span class="number">0</span>x4079b0, s<span class="built_in">a_mask</span>=[PIPE], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_IGN, s<span class="built_in">a_mask</span>=[PIPE], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGCHLD, &#123;s<span class="built_in">a_handler</span>=SIG_DFL, s<span class="built_in">a_mask</span>=[CHLD], s<span class="built_in">a_flags</span>=S<span class="built_in">A_RESTORER</span>|S<span class="built_in">A_RESTART</span>, s<span class="built_in">a_restorer</span>=<span class="number">0</span>x7f1a64463050&#125;, &#123;s<span class="built_in">a_handler</span>=SIG_DFL, s<span class="built_in">a_mask</span>=[], s<span class="built_in">a_flags</span>=<span class="number">0</span>&#125;, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">prlimit64(<span class="number">0</span>, RLIMIT_STACK, NULL, &#123;rlim_cur=<span class="number">8192</span>*<span class="number">1024</span>, rlim_max=RLIM64_INFINITY&#125;) = <span class="number">0</span></span><br><span class="line">prlimit64(<span class="number">0</span>, RLIMIT_STACK, &#123;rlim_cur=<span class="number">65536</span>*<span class="number">1024</span>, rlim_max=RLIM64_INFINITY&#125;, NULL) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/local/bin/gcc&quot;</span>, X_OK)      = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/bin/gcc&quot;</span>, X_OK)            = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/bin/gcc&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1301496</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">readlink(<span class="string">&quot;/usr&quot;</span>, <span class="number">0</span>x7ffea2eb5f60, <span class="number">1023</span>)  = -<span class="number">1</span> EINVAL (Invalid argument)</span><br><span class="line">readlink(<span class="string">&quot;/usr/bin&quot;</span>, <span class="number">0</span>x7ffea2eb5f60, <span class="number">1023</span>) = -<span class="number">1</span> EINVAL (Invalid argument)</span><br><span class="line">readlink(<span class="string">&quot;/usr/bin/gcc&quot;</span>, <span class="string">&quot;gcc-12&quot;</span>, <span class="number">1023</span>) = <span class="number">6</span></span><br><span class="line">readlink(<span class="string">&quot;/usr/bin/gcc-12&quot;</span>, <span class="string">&quot;x86_64-linux-gnu-gcc-12&quot;</span>, <span class="number">1023</span>) = <span class="number">23</span></span><br><span class="line">readlink(<span class="string">&quot;/usr/bin/x86_64-linux-gnu-gcc-12&quot;</span>, <span class="number">0</span>x7ffea2eb5f60, <span class="number">1023</span>) = -<span class="number">1</span> EINVAL (Invalid argument)</span><br><span class="line">access(<span class="string">&quot;/usr/local/bin/gcc&quot;</span>, X_OK)      = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/bin/gcc&quot;</span>, X_OK)            = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/bin/gcc&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1301496</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">readlink(<span class="string">&quot;/usr&quot;</span>, <span class="number">0</span>x7ffea2eb5f60, <span class="number">1023</span>)  = -<span class="number">1</span> EINVAL (Invalid argument)</span><br><span class="line">readlink(<span class="string">&quot;/usr/bin&quot;</span>, <span class="number">0</span>x7ffea2eb5f60, <span class="number">1023</span>) = -<span class="number">1</span> EINVAL (Invalid argument)</span><br><span class="line">readlink(<span class="string">&quot;/usr/bin/gcc&quot;</span>, <span class="string">&quot;gcc-12&quot;</span>, <span class="number">1023</span>) = <span class="number">6</span></span><br><span class="line">readlink(<span class="string">&quot;/usr/bin/gcc-12&quot;</span>, <span class="string">&quot;x86_64-linux-gnu-gcc-12&quot;</span>, <span class="number">1023</span>) = <span class="number">23</span></span><br><span class="line">readlink(<span class="string">&quot;/usr/bin/x86_64-linux-gnu-gcc-12&quot;</span>, <span class="number">0</span>x7ffea2eb5f60, <span class="number">1023</span>) = -<span class="number">1</span> EINVAL (Invalid argument)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/specs&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/12/specs&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/specs&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/specs&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/lto-wrapper&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1180024</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/lto-wrapper&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/tmp&quot;</span>, R_OK|W_OK|X_OK)          = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/tmp&quot;</span>, &#123;st_mode=S_IFDIR|S_ISVTX|<span class="number">0777</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &#123;tv_sec=<span class="number">2059</span>, tv_nsec=<span class="number">553951022</span>&#125;) = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/tmp/ccbdUzto.s&quot;</span>, O_RDWR|O_CREAT|O_EXCL, <span class="number">0600</span>) = <span class="number">3</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/cc1&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">33342568</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/cc1&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">pipe2([<span class="number">3</span>, <span class="number">4</span>], O_CLOEXEC)                = <span class="number">0</span></span><br><span class="line">vfork()                                 = <span class="number">16202</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">16</span>)                         = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">wait4(<span class="number">16202</span>, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == <span class="number">0</span>&#125;], <span class="number">0</span>, NULL) = <span class="number">16202</span></span><br><span class="line">--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=<span class="number">16202</span>, si_uid=<span class="number">1000</span>, si_status=<span class="number">0</span>, si_utime=<span class="number">1</span> <span class="comment">/* 0.01 s */</span>, si_stime=<span class="number">1</span> <span class="comment">/* 0.01 s */</span>&#125; ---</span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &#123;tv_sec=<span class="number">2059</span>, tv_nsec=<span class="number">601463828</span>&#125;) = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/tmp/ccvZGP4P.o&quot;</span>, O_RDWR|O_CREAT|O_EXCL, <span class="number">0600</span>) = <span class="number">3</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/12/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/12/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu-as&quot;</span>, <span class="number">0</span>x7ffea2eb7230, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/as&quot;</span>, <span class="number">0</span>x7ffea2eb72f0, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">pipe2([<span class="number">3</span>, <span class="number">4</span>], O_CLOEXEC)                = <span class="number">0</span></span><br><span class="line">vfork()                                 = <span class="number">16203</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">16</span>)                         = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">wait4(<span class="number">16203</span>, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == <span class="number">0</span>&#125;], <span class="number">0</span>, NULL) = <span class="number">16203</span></span><br><span class="line">--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=<span class="number">16203</span>, si_uid=<span class="number">1000</span>, si_status=<span class="number">0</span>, si_utime=<span class="number">0</span>, si_stime=<span class="number">0</span>&#125; ---</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/collect2&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">639192</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/collect2&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/liblto_plugin.so&quot;</span>, R_OK) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/bin/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/../lib/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">126976</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">126976</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/../lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">126976</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/../lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/.&quot;</span>, <span class="number">0</span>x7ffea2eb7420, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &#123;tv_sec=<span class="number">2059</span>, tv_nsec=<span class="number">611785599</span>&#125;) = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/tmp/ccmo4bus.res&quot;</span>, O_RDWR|O_CREAT|O_EXCL, <span class="number">0600</span>) = <span class="number">3</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/Scrt1.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/12/Scrt1.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/Scrt1.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/../lib/Scrt1.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/12/Scrt1.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/Scrt1.o&quot;</span>, R_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/crti.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/12/crti.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/crti.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/../lib/crti.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/12/crti.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/crti.o&quot;</span>, R_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/crtbeginS.o&quot;</span>, R_OK) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/../lib/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">126976</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">126976</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/lib/../lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/x86_64-linux-gnu/12/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/x86_64-linux-gnu/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">126976</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/../lib/.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/.&quot;</span>, <span class="number">0</span>x7ffea2eb6640, <span class="number">0</span>) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../.&quot;</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">4096</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/crtendS.o&quot;</span>, R_OK) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/crtn.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/12/crtn.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/crtn.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/lib/../lib/crtn.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/12/crtn.o&quot;</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file <span class="literal">or</span> directory)</span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu/crtn.o&quot;</span>, R_OK) = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/collect2&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">639192</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">access(<span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/12/collect2&quot;</span>, X_OK) = <span class="number">0</span></span><br><span class="line">pipe2([<span class="number">3</span>, <span class="number">4</span>], O_CLOEXEC)                = <span class="number">0</span></span><br><span class="line">vfork()                                 = <span class="number">16204</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">16</span>)                         = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">wait4(<span class="number">16204</span>, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == <span class="number">0</span>&#125;], <span class="number">0</span>, NULL) = <span class="number">16204</span></span><br><span class="line">--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=<span class="number">16204</span>, si_uid=<span class="number">1000</span>, si_status=<span class="number">0</span>, si_utime=<span class="number">0</span>, si_stime=<span class="number">0</span>&#125; ---</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/tmp/ccmo4bus.res&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0600</span>, st_size=<span class="number">0</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">unlink(<span class="string">&quot;/tmp/ccmo4bus.res&quot;</span>)             = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/tmp/ccvZGP4P.o&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0600</span>, st_size=<span class="number">1384</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">unlink(<span class="string">&quot;/tmp/ccvZGP4P.o&quot;</span>)               = <span class="number">0</span></span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/tmp/ccbdUzto.s&quot;</span>, &#123;st_mode=S_IFREG|<span class="number">0600</span>, st_size=<span class="number">541</span>, ...&#125;, <span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">unlink(<span class="string">&quot;/tmp/ccbdUzto.s&quot;</span>)               = <span class="number">0</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br></pre></td></tr></table></figure>

<p>信息非常乱， 但是我先列出每个函数的作用（生成自gpt）：</p>
<h3 id="系统调用解释"><a href="#系统调用解释" class="headerlink" title="系统调用解释"></a>系统调用解释</h3><p>以下是对提供的<code>strace</code>输出中每行开头的系统调用或相关函数的解释：</p>
<ul>
<li><p><strong><code>execve</code></strong>: 执行一个程序，是程序运行的起点。替换当前进程的映像、数据和堆栈等为新程序的映像和数据，新程序从<code>main</code>开始执行。</p>
</li>
<li><p><strong><code>brk</code></strong>: 调整数据段末尾的地址，用于增加或减少数据段的大小，即动态分配或释放内存。</p>
</li>
<li><p><strong><code>mmap</code></strong>: 创建一个新的映射（mapping）在调用进程的虚拟地址空间，用于分配内存或将文件直接映射到内存中。</p>
</li>
<li><p><strong><code>access</code></strong>: 检查调用进程是否可以访问指定的文件路径，用于检查文件是否存在及其读写权限。</p>
</li>
<li><p><strong><code>openat</code></strong>: 打开一个文件或目录，<code>AT_FDCWD</code>表示相对于当前工作目录的路径。</p>
</li>
<li><p><strong><code>newfstatat</code></strong>: 获取文件的状态信息，如大小、权限、最后修改时间等。</p>
</li>
<li><p><strong><code>close</code></strong>: 关闭一个文件描述符，释放其所占用的资源。</p>
</li>
<li><p><strong><code>read</code></strong>: 从文件描述符指向的文件中读取数据。</p>
</li>
<li><p><strong><code>pread64</code></strong>: 从文件描述符指向的文件中读取数据，可以指定从哪个位置开始读取，不改变文件的当前偏移量。</p>
</li>
<li><p><strong><code>arch_prctl</code></strong>: 设置特定架构的进程或线程的状态，如线程局部存储区域。</p>
</li>
<li><p><strong><code>set_tid_address</code></strong>: 设置线程ID的存储地址，用于内核在特定事件（如线程退出）时更新信息。</p>
</li>
<li><p><strong><code>set_robust_list</code></strong>: 设置线程的鲁棒列表（robust list），用于处理锁的死亡解锁。</p>
</li>
<li><p><strong><code>rseq</code></strong>: 重启序列系统调用，用于在用户空间实现快速的锁和同步机制。</p>
</li>
<li><p><strong><code>mprotect</code></strong>: 改变一块内存区域的保护属性，如设置为只读。</p>
</li>
<li><p><strong><code>ioctl</code></strong>: 对设备特定的输入&#x2F;输出操作进行控制。</p>
</li>
<li><p><strong><code>rt_sigaction</code></strong>: 检查或修改与特定信号相关联的处理动作。</p>
</li>
<li><p><strong><code>prlimit64</code></strong>: 获取或设置进程资源限制，如最大可用内存、最大打开文件数等。</p>
</li>
<li><p><strong><code>getrandom</code></strong>: 从内核的随机数生成器获取随机数。</p>
</li>
<li><p><strong><code>unlink</code></strong>: 删除一个文件的链接，如果是文件的最后一个链接，并且没有进程打开该文件，则文件被删除。</p>
</li>
<li><p><strong><code>exit_group</code></strong>: 终止调用进程所在的整个进程组，通常在程序结束时调用。</p>
</li>
</ul>
<p>下面对追踪信息进行基本解释：</p>
<h1 id="GCC编译器执行过程分析"><a href="#GCC编译器执行过程分析" class="headerlink" title="GCC编译器执行过程分析"></a>GCC编译器执行过程分析</h1><h2 id="第1段：程序启动和初始化（行1-15）"><a href="#第1段：程序启动和初始化（行1-15）" class="headerlink" title="第1段：程序启动和初始化（行1-15）"></a>第1段：程序启动和初始化（行1-15）</h2><p>这一段描述了gcc编译器启动的初始步骤。<code>execve</code>系统调用用于执行gcc程序，后续的<code>brk</code>和<code>mmap</code>调用进行内存分配和管理，为程序的运行准备必要的资源。接着，通过<code>openat</code>和<code>read</code>系统调用，程序尝试访问和读取系统的动态链接器配置（<code>/etc/ld.so.cache</code>）和标准C库（<code>libc.so.6</code>），这是程序运行前的必要准备，以确保能够正确链接到所需的共享库。</p>
<h2 id="第2段：环境设置（行16-27）"><a href="#第2段：环境设置（行16-27）" class="headerlink" title="第2段：环境设置（行16-27）"></a>第2段：环境设置（行16-27）</h2><p>程序继续进行环境设置，包括通过<code>mmap</code>为特定的数据结构分配更多内存，设置线程特定的数据（如<code>arch_prctl</code>调用设定线程的FS寄存器），并进行一些内存保护设置（<code>mprotect</code>调用）。这一部分的操作主要关注于为程序的执行和系统调用提供必要的环境配置。</p>
<h2 id="第3段：本地化和错误消息处理（行28-49）"><a href="#第3段：本地化和错误消息处理（行28-49）" class="headerlink" title="第3段：本地化和错误消息处理（行28-49）"></a>第3段：本地化和错误消息处理（行28-49）</h2><p>gcc尝试加载本地化支持文件，以便能够显示本地化的错误消息。通过一系列的<code>openat</code>调用搜索本地化文件，所有尝试均返回<code>ENOENT</code>（文件不存在），说明在指定的路径下没有找到相应的本地化文件。我没有下载本地化文件，所以这一步会加载失败，并且如果GCC未找到对应的.mo文件，它会回退到默认的（通常是英文）消息。此外，<code>ioctl</code>调用的失败表明尝试获取终端属性未成功，这通常是因为gcc可能在没有终端的环境中运行（例如，脚本或其他自动化工具中）。</p>
<blockquote>
<h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>本地化（Localization），通常简写为l10n（因为单词中”L”和”n”之间有10个字母），指的是将产品（如软件、文档、网站等）或内容调整以适应特定地区或语言的用户的过程。这不仅涉及到翻译文本内容，还包括符合当地文化、法律和需求的各种适应性调整。本地化的目标是为用户提供尽可能亲切和自然的使用体验，使产品看起来像是为特定的用户群体量身定做的。以下是本地化过程中常涉及的一些关键方面：</p>
<ol>
<li>语言和文本翻译</li>
</ol>
<p>将产品界面、帮助文档、用户手册等文本从一种语言翻译到另一种语言，确保语言的准确性和地道性。</p>
<ol start="2">
<li>文化适应性</li>
</ol>
<p>考虑和适应目标地区的文化习俗和预期，如颜色、图标的文化含义，以及布局方式等，以避免文化冲突或误解。</p>
<ol start="3">
<li>法律和规范遵循</li>
</ol>
<p>确保产品符合目标地区的法律法规和业务习惯，包括隐私政策、版权信息、数据保护规则等。</p>
<ol start="4">
<li>技术适应性</li>
</ol>
<p>适应目标地区的技术标准和习惯，如日期和时间格式、数字格式（小数点和千位分隔符）、度量单位（公制或英制）、货币单位等。</p>
<ol start="5">
<li>排版和界面调整</li>
</ol>
<p>根据语言的阅读方向（如从左到右或从右到左）调整用户界面的布局和排版，确保界面元素的适当展示和用户交互的便利性。<br>通过本地化，可以大大增强用户体验，提高产品的市场接受度和用户满意度。对于全球市场的软件开发者而言，本地化是一个重要的步骤，有助于将产品推广到不同语言和文化背景的用户中。</p>
</blockquote>
<h2 id="第4段：编译前的准备（行50-95）"><a href="#第4段：编译前的准备（行50-95）" class="headerlink" title="第4段：编译前的准备（行50-95）"></a>第4段：编译前的准备（行50-95）</h2><p>这段涉及到编译前的准备工作，包括对信号处理的设置（如<code>rt_sigaction</code>调用），以确保在编译过程中能够正确处理诸如中断（SIGINT）和挂起（SIGHUP）等信号。接着，gcc进行一系列的路径和文件检查，确认编译器组件和工具链的位置（如查找gcc，cc1，以及相关库文件的位置）。这些步骤确保了编译过程可以找到所有必要的编译器组件和工具。</p>
<h2 id="第5段：编译过程（行96-204）"><a href="#第5段：编译过程（行96-204）" class="headerlink" title="第5段：编译过程（行96-204）"></a>第5段：编译过程（行96-204）</h2><p>这是实际编译过程的核心部分，涉及多个阶段，包括预处理、编译、汇编和链接。在这一段中，gcc生成了临时文件（如汇编代码文件），调用子进程（通过<code>vfork</code>和<code>execve</code>）来执行如cc1（gcc的编译器前端），汇编器（as），以及链接器（ld或collect2）。此外，通过<code>pipe2</code>和<code>wait4</code>等系统调用进行进程间通信和同步，确保编译过程按顺序进行。各种临时文件被创建和删除（<code>unlink</code>），是编译过程中间步骤的产物。</p>
<h2 id="第6段：清理和退出（行205-210）"><a href="#第6段：清理和退出（行205-210）" class="headerlink" title="第6段：清理和退出（行205-210）"></a>第6段：清理和退出（行205-210）</h2><p>在编译任务完成后，gcc进行清理工作，包括删除临时文件，并最终通过<code>exit_group</code>系统调用退出程序。这表示编译过程已经全部完成，所有资源被适当地释放，gcc以返回状态码0正常退出，标志着编译成功。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>linux C</tag>
      </tags>
  </entry>
  <entry>
    <title>分层领域模型解读</title>
    <url>/2025/02/26/%E5%88%86%E5%B1%82%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在开发项目的时候碰到了领域模型，但是并没有对其中的各层关系以及各层传递数据方式理解清晰。在此记录下分层领域模型数据的传递过程</p>
<h2 id="所谓领域模型"><a href="#所谓领域模型" class="headerlink" title="所谓领域模型"></a>所谓领域模型</h2><p>所谓领域模型，其实就是<strong>C++类</strong>，再详细一点就是有作用范围的实体类。</p>
<p>其核心目标是<strong>业务抽象</strong>：将现实业务中的实体、流程和规则转化为可被代码理解和操作的结构。</p>
<p>其中的领域对象描述是这样的：</p>
<ul>
<li><code>DO</code>（Data Object）：此对象与数据库表结构一一对应，通过 <code>DAO</code> 层向上传输数据源对象。</li>
<li><code>DTO</code>（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。 </li>
<li><code>BO</code>（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</li>
<li><code>Query</code>：数据查询对象，各层接收上层的查询请求。</li>
<li><code>VO</code>（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>
</ul>
<p><img src="/2025/02/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/layer.png" alt="img"></p>
<span id="more"></span>

<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p><strong>订单领域模型</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">聚合根：Order（订单）</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>实体：OrderItem（订单项）</span><br><span class="line"><span class="bullet">- </span>值对象：Address（配送地址）</span><br><span class="line"><span class="bullet">- </span>领域服务：OrderService（处理订单创建、取消）</span><br><span class="line"><span class="bullet">- </span>领域事件：OrderCreatedEvent（订单创建事件）</span><br><span class="line"><span class="bullet">- </span>仓储：OrderRepository（持久化订单）</span><br></pre></td></tr></table></figure>

<p>很明显可以看出领域模型与数据模型不同，领域模型的代码直接反映业务概念，领域模型关注行为，而数据模型关注存储。领域模型的业务逻辑独立于基础设施，<strong>每个微服务对应一个限界上下文，领域模型帮助定义服务边界。</strong>最重要的是有限界上下文，要明白模型的边界。而且领域模型也不等同于数据库表，模型可以随业务需求演进，而非受限于数据库结构。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>领域模型是<strong>以业务为核心</strong>的设计方法，通过抽象关键概念、规则和交互，帮助开发者构建灵活、可维护的系统。它不仅是技术工具，更是一种思维方式，强调从业务视角出发解决问题。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>领域模型 业务设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust_Intro</title>
    <url>/2025/06/16/Rust-Intro/</url>
    <content><![CDATA[<blockquote>
<p>此分类（<em>The Rust Programming Language</em>）采用brown university的<a href="https://rust-book.cs.brown.edu/">实验版本</a>, 对细节进行解释同时进行学习记录</p>
</blockquote>
<p><img src="/2025/02/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Ferris.png" alt="image-20250616162739328"></p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a><a href="https://rust-book.cs.brown.edu/ch01-00-getting-started.html#getting-started">Getting Started</a></h2><ul>
<li><p><code>rustup</code> 来管理机器上的Rust版本</p>
</li>
<li><pre><code class="shell">rustc main.rs				// rustc的用法, rustfmt也可以这么使用
rustfmt main.rs				// 使用rust的语法格式化文档
./main
</code></pre>
</li>
<li><p><code>cargo init</code>: 自动获取cargo.toml文件\</p>
</li>
<li><p>cargo.lock文件追踪准确的版本依赖</p>
</li>
<li><p><code>cargo run</code>  只有代码发生改变的时候才会重新编译运行, 否则直接运行</p>
</li>
<li><p><code>cargo build --release</code>会在target&#x2F;release下生成目标文件, 会让Rust代码运行更快,没有debug. 如果要衡量代码效率就是用此命令编译</p>
<span id="more"></span></li>
</ul>
]]></content>
      <categories>
        <category>The Rust Programming Language</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈智能指针</title>
    <url>/2025/02/20/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>野指针（Wild Pointer）： 野指针是指指向任意未知位置的指针，它没有被初始化或者指向无效的内存。</p>
<p>悬挂指针（dangling pointer）：指指向已释放或无效内存的指针。当一个指向动态分配内存的指针所指向的内存被释放后，该指针仍然保留着原来的指向，但此时使用该指针访问所指向的内存将导致未定义的行为。</p>
<p>RAII (Resource Acquisition Is Initialization): 资源获取即初始化， R使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。像下面的例子：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">str_</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">str_</span>() &#123; data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span>]; &#125;</span><br><span class="line">    ~<span class="built_in">str_</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data_&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pdata = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span>];			<span class="comment">// 这样的做法容易漏掉delete，导致内存泄漏</span></span><br><span class="line">    <span class="keyword">delete</span>[] pdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这样当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就被毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显式调用完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        str_ data;							</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>因为C++使用内存的时候很容易出现野指针、悬空指针、内存泄露等问题。所以C++11引入了智能指针来管理内存。使用智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）来自动管理资源生命周期，避免手动释放内存和引入悬垂指针和野指针问题。共有四种智能指针:</p>
<ul>
<li><code>auto_ptr</code>：已经不用了</li>
<li><code>unique_ptr</code>：独占式指针，同一时刻只能有一个指针指向同一个对象</li>
<li><code>shared_ptr</code>：共享式指针，同一时刻可以有多个指针指向同一个对象</li>
<li><code>weak_ptr</code>：用来解决<code>shared_ptr</code>相互引用导致的死锁问题</li>
</ul>
<p>总的来说，智能指针是一个RAII类模板，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所执行的内存空间。</p>
<ul>
<li><p><code>unique_ptr</code>:</p>
<ul>
<li><p>独占式指针，与所指对象的内存绑定紧密，禁止其他智能指针与其他共享同一个对象。也就是<strong>同一时间只能有一个智能指针可以指向该对象</strong></p>
</li>
<li><p>独占的意思是不可以复制(拷贝构造和拷贝复制)，但是我们可以利用std::move将其转移给其他unique_ptr(可以移动构造和移动赋值)。一旦转移，这个所有权就会失去，除非被显示归还</p>
</li>
<li><p>从实现上来讲，unique_ptr是一个删除了拷贝构造函数，保留了移动构造函数的指针类型。可以使用右值对unique_ptr进行构造</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>shared_ptr</code>：</p>
<ul>
<li>实现了共享式拥有的概念，即<strong>多个智能指针可以指向相同的对象，该对象以及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源</strong></li>
</ul>
<ul>
<li><p>它是使用计数机制来表明资源被几个指针共享</p>
</li>
<li><p>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊auto_ptr,unique_ptr,weak_ptr 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0时，资源会被释放。</p>
</li>
</ul>
</li>
<li><p><code>weak_ptr</code>，解决shared_ptr相互引用的问题，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。</p>
<ul>
<li><p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手而不是智能智能，因为它没有普通指针的行为，没有重置*和→。它得最大作用是协助shared_ptr工作，像是旁观者那样观测资源的使用情况</p>
</li>
<li><p>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr</p>
</li>
<li><p>weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为了配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它只可以从一个 shared_ptr 或另⼀个 weak_ptr 对象构造,，它的构造和析构不会引起引用计数的增加或者减少</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C/CPP</category>
      </categories>
      <tags>
        <tag>C/C++ 智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust_GuessingGame</title>
    <url>/2025/06/16/Rust-GuessingGame/</url>
    <content><![CDATA[<ul>
<li><p>一般crate使用<code>use</code>导入, 但是Rust会自动导入<code>prelude</code>,里面包含了基本的功能, 详见<a href="https://doc.rust-lang.org/std/prelude/index.html">standard library documentation</a>.</p>
</li>
<li><p>Rust中的变量默认是不可变的, 可以添加<code>mut</code>关键字使之改变</p>
</li>
<li><p><code>read_line</code>读取用户输入,并将其<strong>添加</strong>到字符串尾端(append), 而不是覆盖, 不同于<code>cin</code> </p>
</li>
<li><p><code>read_line</code>会返回一个Result值</p>
</li>
<li><p><code>Result</code>是一个枚举类型,其中有<code>Ok</code>和<code>Err</code>, 所以可以使用<code>read_line(&amp;mut guess).expect(&quot;Failed to read&quot;)</code>  expect函数来处理错误读入, <strong>任何类型的值都有其方法</strong></p>
</li>
<li><p>正常情况下,<code>expect()</code>方法会返回用户输入的字节数</p>
</li>
<li><p><code>println!()</code> 可以使用{}来输出变量, 但是如果变量名称不存在就会报错</p>
</li>
<li><p><code>crate</code>是一组Rust源代码文件,用户构建的项目是一个二进制<code>crate</code>, 它是一个可执行文件. <code>rand crate</code>是一个库crate, <strong>它包含的代码用于其他程序, 并不能单独运行</strong></p>
<span id="more"></span>
</li>
<li><h4 id="Semanic-Versioning"><a href="#Semanic-Versioning" class="headerlink" title="Semanic Versioning"></a>Semanic Versioning</h4><ul>
<li>核心规则是一个三部分版本号: MAJOR. MINOR. PATCH(主版本号, 次版本号, 修订号).</li>
<li><strong>PATCH (修订号)<strong>：当你做了</strong>向后兼容的 Bug 修复</strong>时，增加修订号。例如，从 <code>1.0.0</code> 到 <code>1.0.1</code>。这意味着使用 <code>1.0.0</code> 的代码升级到 <code>1.0.1</code> 时，不会出现编译错误或运行时问题。</li>
<li><strong>MINOR (次版本号)<strong>：当你做了</strong>向后兼容的新功能添加</strong>时，增加次版本号。例如，从 <code>1.0.0</code> 到 <code>1.1.0</code>。这意味着你在不破坏现有公共 API 的情况下增加了新功能。旧代码仍然可以正常工作，并且可以利用新功能。</li>
<li><strong>MAJOR (主版本号)<strong>：当你做了</strong>不兼容的 API 更改</strong>时（即引入了破坏性变更），增加主版本号。例如，从 <code>1.0.0</code> 到 <code>2.0.0</code>。这意味着使用 <code>1.0.0</code> 的代码在升级到 <code>2.0.0</code> 时可能会出现编译错误或运行时问题，需要修改代码以适应新的 API。</li>
</ul>
<p><strong>Rust 生态系统与 SemVer 的关系：</strong></p>
<ol>
<li><strong>Cargo 的核心原则</strong>：Rust 的包管理器 Cargo 默认高度依赖 SemVer。当你将一个 crate（Rust 中的包）添加到 <code>Cargo.toml</code> 文件的依赖项中时，例如 <code>my_crate = &quot;1.2.3&quot;</code>，Cargo 会根据 SemVer 规则自动解析并选择一个兼容的版本。这极大地简化了依赖管理，因为开发者可以相对放心地升级次版本和修订版本，而不用担心代码中断。</li>
<li><strong><code>0.y.z</code> 版本的特殊性</strong>：根据 SemVer 规范，主版本号为 <code>0</code> 的版本（即 <code>0.y.z</code>）被视为处于初始开发阶段，此时即使是次版本号的增加（如从 <code>0.1.0</code> 到 <code>0.2.0</code>）也可以引入破坏性变更。这是因为在 <code>1.0.0</code> 之前，API 稳定性通常还不被保证。不过，在 Cargo 中，对于 <code>0.x.y</code> 形式的版本，<code>0.x.z</code> 被认为是与 <code>0.x.y</code> 兼容的（当 <code>z &gt;= y</code> 且 <code>x &gt; 0</code> 时），这与标准 SemVer 对 <code>0.y.z</code> 的处理略有不同。</li>
<li><strong>自动化工具</strong>：由于手动遵守 SemVer 规则可能非常复杂且容易出错，Rust 社区开发了像 <code>cargo-semver-checks</code> 这样的自动化工具。这些工具可以分析你的 crate 代码与最新发布版本之间的差异，并自动检测是否存在违反 SemVer 规则的破坏性变更，从而帮助开发者在发布新版本之前发现并解决问题。</li>
</ol>
</li>
<li><p><code>gen_range(1..=100)</code> 随机数生成[1, 100]</p>
</li>
<li><p><code>match</code>语句在第一次匹配之后结束</p>
</li>
<li><pre><code class="rust">let mut guess = String::new();

io::stdin()
    .read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;)	// Rust中可以使用新变量覆盖旧变量, 此行作用是将guess转为u32类型
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  `trim()`方法用来消除字符串收尾的空白字符,`\n` `\r`等等</span><br><span class="line"></span><br><span class="line">  `parse()`方法用来将字符串转换成另一个类型</span><br><span class="line"></span><br><span class="line">+ ```rust</span><br><span class="line"><span class="title">  let guess:</span> u32 = match guess.trim().parse() &#123;</span><br><span class="line">  	Ok(num) =&gt; num,				// 注意这里用的逗号</span><br><span class="line">      Err(_) =&gt; <span class="keyword">continue</span>,			// _(下划线)代表获取所有值</span><br><span class="line">  &#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>整体完成的代码, guessing_name.rs</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your number&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        </span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    	.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">    	.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">			Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>The Rust Programming Language</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust_CommonConcept</title>
    <url>/2025/06/17/Rust-CommonConcept/</url>
    <content><![CDATA[<ul>
<li><p>Rust中的变量默认是不可变的, 但是可以添加<code>mut</code>关键字使之可变</p>
<p>Rust有单次赋值(Single assignment)原则, 尽管Rust变量默认是不可变的, 但是它允许你在声明变量后延迟赋值一次, 只要编译器能确定该变量只会被赋值一次即可.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的语句是可以通过编译的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>;</span><br><span class="line"><span class="keyword">if</span> cond &#123;</span><br><span class="line">	x = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量声明方式:<span id="more"></span></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SENCONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>常量不允许使用<code>mut</code>关键字来修饰, 也就是说常量是不可改变的.</p>
<p>常量存活在程序运行的整个生命周期, 也就是说在常量定义的范围内一直生效</p>
</li>
<li><p><strong>Shadowing</strong>: 新变量覆盖了旧变量,导致在特定作用域内旧变量的值不可见</p>
</li>
<li><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>整形:</strong><img src="/2025/02/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Concept/DataType.png" alt="DataType"></p>
<p>其中,有符号数采用二进制补码存储, <code>isize</code>和<code>usize</code>取决于计算机的架构</p>
<p>另外编译的时候,如果使用debug模式, 编译器会检查整形溢出. 但是如果采用release模式, 则不会进行溢出检查, 而是会类型回绕</p>
</li>
</ul>
<p>​	<strong>浮点数:</strong> 默认为<code>f64</code>, 根据IEEE-754标准表示</p>
<p>​	<strong>布尔类型:</strong>  <code>true</code> <code>false</code></p>
<p>​	<strong>字符类型:</strong> 一个Rust字符占4字节, 可以表示其他语言, 并且零宽空格也是有效的char值</p>
<p>​	<strong>元组类型:</strong> 固定长度, 元组中的元素类型不必相同 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​	可以通过模式匹配(pattern matching)解构元组值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;y&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	也可以通过点(.)来获取每个位置的元素</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">two</span> = x.<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">three</span> = x.<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>​	空元组也叫单元(unit), 这个值及对应类型都写作(), 代表空值或者空返回类型.如果表达式没有返回其他任何值, 则隐式返回单元值.</p>
<p>​	</p>
<p>​	<strong>数组类型</strong>: 固定长度, 每个元素类型都相同</p>
<p>​	声明方式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">              <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];			<span class="comment">// 声明为5个i32类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];			<span class="comment">// 生成5个3</span></span><br></pre></td></tr></table></figure>

<p>​	可以通过中括号声明, eg: months[1], month[2] st.</p>
<ul>
<li><p><strong>Statements(语句) 和 Expressions(表达式)</strong></p>
<ul>
<li><p>语句是执行某些操作但不返回值的操作</p>
<ul>
<li><p>let 绑定</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表达式语句</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>;</span><br><span class="line">y + <span class="number">1</span>;			<span class="comment">// 这是一个语句, y + 1的结果被丢弃了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数定义</p>
</li>
<li><p>宏调用（作为语句）： <code>println!(&quot;Hello, world!&quot;);</code> （虽然 <code>println!</code> 是一个宏，但当它用作打印输出时，通常作为不返回值的语句使用）</p>
</li>
<li><p><strong>任何以分号结尾的表达式：</strong></p>
</li>
</ul>
</li>
<li><p>表达式是 Rust 中会计算并<strong>产生一个值</strong>的代码块。它们可以由字面量、变量、运算符、函数调用、宏调用，甚至由花括号包围的代码块组成。可以用于赋值, 并且<strong>通常不以分号结尾</strong>, 如果以分号结尾,它就会变成一个语句, 其返回值会被丢弃.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span>		<span class="comment">// 这是一个表达式, 返回4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// now y is 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结区别"><a href="#总结区别" class="headerlink" title="总结区别"></a>总结区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>表达式 (Expressions)</th>
<th>语句 (Statements)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>返回值</strong></td>
<td><strong>会返回值</strong></td>
<td><strong>不返回值</strong></td>
</tr>
<tr>
<td><strong>结尾</strong></td>
<td>通常不以分号结尾（在作为代码块的最后一行时）</td>
<td><strong>通常以分号结尾</strong></td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>计算并产生一个值</td>
<td>执行一个操作</td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>1 + 2</code>, <code>&#123; let x = 3; x + 1 &#125;</code>, <code>if cond &#123; 1 &#125; else &#123; 0 &#125;</code></td>
<td><code>let x = 5;</code>, <code>println!(&quot;Hello!&quot;);</code>, <code>x = 10;</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<p>声明方法: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello, wworld!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">another_funtion</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_funtion</span>(x: <span class="type">i32</span>) &#123;			<span class="comment">// 必须定义函数形参的类型</span></span><br><span class="line">	prinlin!(<span class="string">&quot;Another funtion.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;		<span class="comment">// 有返回值的函数</span></span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">    <span class="comment">// return x + 1;		// 显式返回也可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust不在乎在哪里定义函数(调用前, 调用后), 只要函数被定义在调用者可以看到的作用域中即可.</p>
</li>
<li><p><strong>控制流</strong></p>
<ul>
<li><p>条件控制</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;				<span class="comment">// if 后面一定是跟一个bool类型, 如果是其他类型并不会隐式转换为bool类型</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;			<span class="comment">// 这里的两个分支都必须是相同的类型, 不然会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is &#123;number&#125;. &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Rust需要在编译时需要知道变量的类型, 而不是运行时再做推断, 所以如果使用上面的语句来进行赋值的时候, 不同分支返回的都必须是相同的类型.</p>
</li>
<li><p>循环</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">		cnt += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> cnt * <span class="number">2</span>;			<span class="comment">// 使用break 中断循环并且返回值</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有嵌套循环, 可以通过标签来标注某个特定的循环并且可以<code>break</code>掉特的循环:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">loopwithlabels</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cnt</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;			<span class="comment">// 使用单引号来声明一个标签</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cnt = &#123;cnt&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End cnt = &#123;cnt&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while 循环: 与其他语言十分相似</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历集合:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过while循环来遍历 */</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">idx</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">while</span> idx &lt; <span class="number">5</span> &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;the value is &#123;&#125;&quot;</span>, a[idx]);</span><br><span class="line">        </span><br><span class="line">        idx += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过for循环遍历, 推荐 */</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;the value is &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>The Rust Programming Language</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust_Ownership</title>
    <url>/2025/06/22/Rust-Ownership/</url>
    <content><![CDATA[<p><strong>Rust在编译时避免未定义行为而不是在运行时</strong></p>
<ul>
<li><p>使用<code>Box</code>来在堆中定义变量:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0</span>; <span class="number">1_000_000</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a;			<span class="comment">// a的所有权被移动到b</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/02/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/hip/Box.png" alt="Box"> </p>
</li>
<li><pre><code class="rust">fn dereferencing() &#123;
    let mut x: Box&lt;i32&gt; = Box::new(1);
    println!(&quot;x = &#123;&#125;&quot;, x);
    let a: i32 = *x;
    *x += 1;

    let r1: &amp;Box&lt;i32&gt; = &amp;x;     // r1 points to x on the stack
    /**
     * println!(&quot;&#123;&#125;&quot;, variable)：用于用户友好的显示。它会通过 Display trait 自动解引用指针和引用，直到找到一个具体的值来显示。
     * println!(&quot;&#123;:p&#125;&quot;, variable)：用于调试和底层观察。它会打印出引用或指针变量本身存储的那个内存地址。
     */
    println!(&quot;r1 = &#123;:p&#125;&quot;, r1);
    /**
     * 下面是错误的, 因为rust为了内存安全规定: 一个值在同一时间只能有一个owner;
     */
    // let b: Box&lt;i32&gt; = *r1;  
    let b: i32 = **r1;
    println!(&quot;b = &#123;&#125;&quot;, b);

    let r2: &amp;i32 = &amp;*x;     // &amp;*x 确实得到了 *x 所在位置的“地址”，但 Rust 把它包装成了一个更安全、更受限制的类型，叫做“引用 (&amp;)” 
    println!(&quot;r2 = &#123;&#125;&quot;, r2);
    let c = *r2;
    println!(&quot;c = &#123;&#125;&quot;, c);
&#125;
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">    subgraph <span class="string">&quot;内存区域&quot;</span></span><br><span class="line">        subgraph <span class="string">&quot;栈 (Stack Memory)&quot;</span></span><br><span class="line">            direction TB</span><br><span class="line">            </span><br><span class="line">            addr_x[<span class="string">&quot;@ 0x7ffc_A0&quot;</span>] -- <span class="string">&quot;变量 x&quot;</span> --&gt; val_x[<span class="string">&quot;&lt;b&gt;值: 0x55ef_B0&lt;/b&gt;&lt;br/&gt;(类型: Box&amp;lt;i32&amp;gt;)&quot;</span>]</span><br><span class="line">            addr_a[<span class="string">&quot;@ 0x7ffc_A8&quot;</span>] -- <span class="string">&quot;变量 a&quot;</span> --&gt; val_a[<span class="string">&quot;值: 1&lt;br/&gt;(类型: i32)&quot;</span>]</span><br><span class="line">            addr_r1[<span class="string">&quot;@ 0x7ffc_AC&quot;</span>] -- <span class="string">&quot;变量 r1&quot;</span> --&gt; val_r1[<span class="string">&quot;&lt;b&gt;值: 0x7ffc_A0&lt;/b&gt;&lt;br/&gt;(类型: &amp;amp;Box&amp;lt;i32&amp;gt;)&quot;</span>]</span><br><span class="line">            addr_b[<span class="string">&quot;@ 0x7ffc_B4&quot;</span>] -- <span class="string">&quot;变量 b&quot;</span> --&gt; val_b[<span class="string">&quot;值: 2&lt;br/&gt;(类型: i32)&quot;</span>]</span><br><span class="line">            addr_r2[<span class="string">&quot;@ 0x7ffc_B8&quot;</span>] -- <span class="string">&quot;变量 r2&quot;</span> --&gt; val_r2[<span class="string">&quot;&lt;b&gt;值: 0x55ef_B0&lt;/b&gt;&lt;br/&gt;(类型: &amp;amp;i32)&quot;</span>]</span><br><span class="line">            addr_c[<span class="string">&quot;@ 0x7ffc_C0&quot;</span>] -- <span class="string">&quot;变量 c&quot;</span> --&gt; val_c[<span class="string">&quot;值: 2&lt;br/&gt;(类型: i32)&quot;</span>]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        subgraph <span class="string">&quot;堆 (Heap Memory)&quot;</span></span><br><span class="line">            addr_heap[<span class="string">&quot;@ 0x55ef_B0&quot;</span>] -- <span class="string">&quot;Box&amp;lt;T&amp;gt;指向的数据&quot;</span> --&gt; val_heap[<span class="string">&quot;值: 2&lt;br/&gt;(类型: i32)&quot;</span>]</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 箭头表示“指向”关系</span><br><span class="line">    val_x -- <span class="string">&quot;指向堆数据&quot;</span> --&gt; addr_heap</span><br><span class="line">    val_r1 -- <span class="string">&quot;引用栈上的 x&quot;</span> --&gt; addr_x</span><br><span class="line">    val_r2 -- <span class="string">&quot;引用堆上的数据&quot;</span> --&gt; addr_heap</span><br><span class="line">    </span><br><span class="line">    %% 样式</span><br><span class="line">    style val_x fill:#f9f,stroke:#<span class="number">333</span></span><br><span class="line">    style val_r1 fill:#ccf,stroke:#<span class="number">333</span></span><br><span class="line">    style val_r2 fill:#<span class="number">9</span>cf,stroke:#<span class="number">333</span></span><br><span class="line">    style addr_heap fill:#f96,stroke:#<span class="number">333</span>,stroke-width:<span class="number">2</span>px</span><br></pre></td></tr></table></figure>

一些误区: 
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="type">Box</span>:<span class="title function_ invoke__">new</span>(&amp;x);</span><br></pre></td></tr></table></figure>

这时候`***y` 才指向值`0`,  `*y`是`x`的引用(`&amp;x`)类型是`&amp;Box&lt;i32&gt;`, `**y`指向`x`本身(`x: Box&lt;i32&gt;`), `***y`才指向`*x`(即x指向的堆的值`0`).
</code></pre>
</li>
<li><h3 id="Rust-Avoids-Simultaneous-Aliasing-and-Mutation"><a href="#Rust-Avoids-Simultaneous-Aliasing-and-Mutation" class="headerlink" title="Rust Avoids Simultaneous Aliasing and Mutation"></a>Rust Avoids Simultaneous Aliasing and Mutation</h3><p><strong>Pointer Safety Principle</strong>: data should never be aliased and mutated at the same time.</p>
<p><strong>数据不允许同时别名和修改</strong></p>
<p>以<code>Vec</code>为例:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><code>Vec</code>的结构是这样的:<img src="/2025/02/05/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/hip/Vec-struct.png" alt="vec-struct">, <code>Vec</code> 是一个在<strong>栈上</strong>的结构体，它包含三个部分：一个指向<strong>堆内存</strong>的指针 (pointer)、长度 (length) 和容量 (capacity). 其中<code>len</code>代表<code>Vec</code>中实际有多少个元素, <code>capacity</code>代表<code>v</code>的容量是多少(可以放多少元素), <strong>如果<code>v.push</code>之后超过了<code>capacity</code>, <code>buf</code>中的指针就会重新开辟一块内存转移数据并且释放掉原先的内存.</strong></p>
<p>那么如果进行下面的操作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];		<span class="comment">// 这里使用vec!宏来初始化Vec容器, 那么默认len = capacity = 3</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];				<span class="comment">// n 是v[2]的不可变引用immutable reference</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);				<span class="comment">// 这里因为capacity不够, 所以v会重新开辟内存转移数据, 并且释放掉原先的内存</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>);		<span class="comment">// 这里就会报错, 因为n指向的地址已经被释放掉了, 所以这里会报错, 但是如果没有这一句, 编译器则不会报错: 虽然n现在还是指向已经释放的地址,但是编译器会自动判断n在释放地址之后没有再次使用,所以这里编译器不会报错 </span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="References-Change-Permissions-on-Places"><a href="#References-Change-Permissions-on-Places" class="headerlink" title="*References Change Permissions on Places"></a>*<a href="https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html#references-change-permissions-on-places">References Change Permissions on Places</a></h3><p>Permission:</p>
<ul>
<li><strong>Read</strong> (<strong>R</strong>): data can be copied to another location.</li>
<li><strong>Write</strong> (<strong>W</strong>): data can be mutated.</li>
<li><strong>Own</strong> (<strong>O</strong>): data can be moved or dropped.</li>
</ul>
<p>Place: 任何可以放在赋值符号左侧的都可以是place, 比如: Variables, Dereferences of places, Array accesses of places, Field of places like tuples or <code>a.field</code> for structs, any combination of the above</p>
<p>place默认有<code>R(ead)</code>, <code>O(wn)</code>的权限, 如果赋值的时候使用<code>mut</code>符号, 那么还会增加<strong>W</strong>权限</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];		<span class="comment">// v 只有R和O权限</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];	<span class="comment">// v1 有W,R,O权限</span></span><br></pre></td></tr></table></figure>

<p>**首先要明确, 如果place离开作用域, 权限就会被收回, eg: **</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];	<span class="comment">// 此时v有R和O权限</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];		<span class="comment">// 此时v1有R和O的权限</span></span><br><span class="line">    &#125;		<span class="comment">// 这里v1的作用域结束, v1失去所有权限</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">change</span>(v);			<span class="comment">// 因为Vec没有实现Copy Trait所以v是被move到了这个函数中, v的权限也随之移动到了函数中, 当函数结束时, 意味着v的作用域结束, v的权限此时被收回;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);		<span class="comment">// 这里会报错, v已经失去了所有权限</span></span><br><span class="line">    </span><br><span class="line">&#125;	<span class="comment">// main函数是v的作用域, 所以只有在main函数结束的时候, v才会失去所有权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个解决方法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个解决方法</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v_again</span> = <span class="title function_ invoke__">change</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v_again);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个解决方法</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">change</span>(v.<span class="title function_ invoke__">clone</span>());			<span class="comment">// 使用clone方法, 但是clone方法会在堆中新开辟一块内存, 所以会有性能问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三个方法 immutable references</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">change</span>(&amp;v);			<span class="comment">// 使用引用的方式, 这里不会在heap中创建副本</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(v: &amp;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**immutable references(shared references): ** 可以在不移动所有权的情况下提供临时的访问, 但是不能修改数据. 同一时间可以有很多Immutable references</p>
<p>**mutable references(unique references): ** 可以对数据进行修改, 但是同一时间只能有一个mutable reference</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: &amp;<span class="keyword">mut</span> <span class="type">i32</span> = &amp;<span class="keyword">mut</span> v[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此时v失去所有权限</span></span><br><span class="line"><span class="comment">* num只是一个存储v[2]地址的一个指针(引用), 所以num对于它自己本身有R和O的权限(没有使用mut), 注意: v[2]是v内部buf中的ptr地址, 但是v结构的地址不会变</span></span><br><span class="line"><span class="comment">* *num 此时才是存储的v[2]的值, 此时*num有R和W权限(因为是mutable reference), 但是引用就是引用, 所以没有O权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">*num += <span class="number">1</span>;</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>O</code> (Own) 权限永远属于数据的所有者（在这里是 <code>v</code>）。引用 (<code>&amp;</code> 或 <code>&amp;mut</code>) 只是临时“借用”了 <code>R</code> 或 <code>R</code>+<code>W</code> 权限。<code>*num</code> 作为一个“位置 (place)”，它允许被读取和写入，但对这块数据的“生杀大权”（移动或销毁）仍然在 <code>v</code> 手里。</strong></p>
<blockquote>
<p>some questions:</p>
<p>Q&amp;A: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="comment">/* here */</span>			<span class="comment">// s在这里没有任何权限, 因为t是mutable reference, 所以当t生命周期没有结束的时候, s失去了所有权限</span></span><br><span class="line">t.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h3 id="Data-Must-Outlive-All-Of-Its-References"><a href="#Data-Must-Outlive-All-Of-Its-References" class="headerlink" title="*Data Must Outlive All Of Its References"></a>*<a href="https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html#data-must-outlive-all-of-its-references">Data Must Outlive All Of Its References</a></h3><p>直接来看例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s_ref</span> = &amp;s;</span><br><span class="line"><span class="title function_ invoke__">drop</span>(s);	<span class="comment">// 这里s还有引用s_ref, 所以如果这里drop掉, s_ref就会指向无效地址, 如果后续s_ref还有使用(生命周期没有结束), 编译器就会自动检测并报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s_ref);		<span class="comment">// s_ref生命周期没有结束, 但是现在s_ref指向无效地址了, 所以编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器无法看到所有函数的周期, 他只能看到函数的signature(输入和输出), 所以如果引用从函数中返回的时候是安全的, 就会获得<code>F</code>权限</p>
<p><code>F(low)</code>权限: 视为 <strong>“出口许可证”。</strong> 只有当编译器能够证明该引用从其当前上下文中“流出”（例如从函数返回）是安全的时，引用才会获得 <code>F</code> 权限。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first</span>(strings: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_ref</span> = &amp;strings[<span class="number">0</span>];</span><br><span class="line">    s_ref</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不安全的行为:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里的函数是会报错的,因为函数不知道返回的String生命周期和哪个输入一致, 具体在main函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_or</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(strings: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, default: &amp;<span class="symbol">&#x27;b</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span> &#123;	</span><br><span class="line">        &amp;strings[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        default</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[];		<span class="comment">// 这里strings是一个空的Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">default</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">first_or</span>(&amp;strings, &amp;default);	<span class="comment">// 根据first_or函数的定义: 这里会返回default, 所以s的生命周期也和defalut保持一致,但是这里有个问题: 编译器事先并不知道应该返回的生命周期该和strings保持一致还是和default保持一致, 如果和strings保持一致, 那么最后的println!宏会报一个清晰的错误:那么s的生命周期已经结束了, 因为string的生命周期在这一行结束就结束了, 如果和default保持一致, 那么经过下一句, s就会变成悬垂指针也会报错</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(default);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">default</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I live for a long time&quot;</span>); <span class="comment">// `default` 的生命周期很长</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">final_ref</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 进入一个新的、更短的生命周期范围</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I live for a short time&quot;</span>)]; <span class="comment">// `strings` 的生命周期很短</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用这份模糊的合同</span></span><br><span class="line">        final_ref = <span class="title function_ invoke__">first_or</span>(&amp;strings, &amp;default);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// `strings` 在这里被销毁了！它的内存被回收了！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灾难发生点：</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, final_ref); <span class="comment">// `final_ref` 现在指向的是谁？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_or2</span>&lt;<span class="symbol">&#x27;a</span>&gt;(strings: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, default: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(strings.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        &amp;strings[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        default</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们定义了一个<strong>生命周期标签</strong>，名叫 <code>&#39;a</code>。</li>
<li>输入 <code>strings</code> 必须至少活得和 <code>&#39;a&#39;</code> 一样长。</li>
<li>输入 <code>default</code> 也必须至少活得和 <code>&#39;a&#39;</code> 一样长。</li>
<li>最重要的承诺：函数返回的引用，其有效期<strong>最多</strong>和 <code>&#39;a&#39;</code> 一样长。</li>
</ol>
<p>这里的 <code>&#39;a</code> 实际上代表了 <code>strings</code> 和 <code>default</code> 中<strong>较短</strong>的那个生命周期。</p>
<p>编译器看到调用 <code>first_or(&amp;strings, &amp;default)</code>。</p>
<p>它比较了 <code>strings</code>（生命周期短）和 <code>default</code>（生命周期长）的有效期。</p>
<p>它确定了那个更短的有效期，并将其作为这次调用的 <code>&#39;a</code>。</p>
<p>函数返回的 <code>final_ref</code> 因此也获得了这个<strong>较短</strong>的生命周期 <code>&#39;a</code>。</p>
<p>所以，<code>final_ref</code> 的有效范围被严格限定在了那个内部 <code>&#123;&#125;</code> 之中。</p>
<p>当代码试图在 <code>&#123;&#125;</code> 外部使用 <code>println!(&quot;&#123;&#125;&quot;, final_ref)</code> 时，审查员会立刻发现：<code>final_ref</code> 的生命周期已经结束了，它已经失效了！</p>
<p>审查员报告一个新的、明确的错误：“你正在使用一个已经过期的引用。”</p>
<p><strong>重点: ** 当一个函数返回的引用可能来自多个不同的输入时，编译器会因为无法判断这个引用的“保质期”而拒绝编译。</strong>生命周期 <code>&#39;a</code> 就是你给编译器提供的一个明确的“保质期”标签**，你向它承诺，返回的引用的有效期不会超过所有相关输入中最先失效的那个。这样，编译器就能确保安全了。</p>
<blockquote>
<p><strong>Q1:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">incr</span>(n: &amp;<span class="keyword">mut</span> <span class="type">i32</span>) &#123;</span><br><span class="line">  *n += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_ invoke__">incr</span>(&amp;n);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个程序不会通过编译, 因为<code>incr(&amp;n)</code> 传递的是immutable reference, 应该修改为<code>incr(&amp;mut n)</code></p>
<p><strong>Q2:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s3</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">  s3.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world&quot;</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;s2&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序也无法通过编译, 因为s2是immutable reference,所以在s2生命周期还没有结束的时候, 对s3操作是不合法的:<br><strong>借用规则</strong>：“你不能在存在一个活跃的不可变借用的同时，再创建一个可变借用。”</p>
<p><strong>Q3:</strong></p>
<p>Consider this Rust function that pushes a number onto the end of a vector, and then removes and returns the number from the front of the vector:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">give_and_take</span>(v: &amp;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	v.<span class="title function_ invoke__">push</span>(n);    </span><br><span class="line">	v.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Normally, if you try to compile this function, the compiler returns the following error:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">error[E0596]: cannot borrow `*v` <span class="keyword">as</span> mutable, <span class="keyword">as</span> <span class="literal">it</span> <span class="keyword">is</span> behind a `&amp;` reference --&gt; test.rs:<span class="number">2</span>:<span class="number">5</span>  |<span class="number">1</span> | fn give_and_take<span class="function"><span class="params">(v: &amp;Vec&lt;i32&gt;, n: i32)</span> -&gt;</span> i32 &#123;  |                     --------- help: consider changing this <span class="keyword">to</span> be a mutable reference: `&amp;mut Vec&lt;i32&gt;`<span class="number">2</span> |     v.push(n);  |     ^^^^^^^^^ `v` <span class="keyword">is</span> a `&amp;` reference, so the data <span class="literal">it</span> refers <span class="keyword">to</span> cannot be borrowed <span class="keyword">as</span> mutable</span><br></pre></td></tr></table></figure>

<p>Assume that the compiler did NOT reject this function. Select each (if any) of the following programs that could possibly cause undefined behavior if executed. If none of these programs could cause undefined behavior, then check “None of these programs” .</p>
<p>**A: **这里主要的错误是<code>Vec</code>push的时候可能超过capacity, 导致v内部值的地址改变, 最终导致悬垂指针</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="title function_ invoke__">give_and_take</span>(&amp;v, <span class="number">4</span>);	</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n);		<span class="comment">// 这里就会导致错误, 此时n为悬垂指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">k</span> = <span class="title function_ invoke__">give_and_take</span>(&amp;v, <span class="number">4</span>);		<span class="comment">// 这里结束之后, n为悬垂指针了, 但是n在后续并没有使用(生命周期已经结束), 所以编译器不会报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span> = &amp;v;</span><br><span class="line"><span class="title function_ invoke__">give_and_take</span>(&amp;v, <span class="number">4</span>);			<span class="comment">// 这里改变的是v内部buf中ptr的值, 而不是v结构体的地址,所以当内部地址改变的时候v2内部也会发生改变, 不会报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><a href="https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html#summary">Summary</a></h3><p>References provide the ability to read and write data without consuming ownership of it. References are created with borrows (<code>&amp;</code> and <code>&amp;mut</code>) and used with dereferences (<code>*</code>), often implicitly.</p>
<p>However, references can be easily misused. Rust’s borrow checker enforces a system of permissions that ensures references are used safely:</p>
<ul>
<li>All variables can read, own, and (optionally) write their data.</li>
<li>Creating a reference will transfer permissions from the borrowed place to the reference.</li>
<li>Permissions are returned once the reference’s lifetime has ended.</li>
<li>Data must outlive all references that point to it.</li>
</ul>
]]></content>
      <categories>
        <category>The Rust Programming Language</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
</search>
